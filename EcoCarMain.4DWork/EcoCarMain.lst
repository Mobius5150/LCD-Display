file C:\Users\Mikester\Documents\GitHub\LCD-Display\EcoCarMain.4Dg

file C:\Program Files (x86)\4D Labs\4D Workshop 4 IDE\include\uLCD-43PT.fnc

000001  000001  #platform "uLCD-43PT"
000002  000001  #platform "uLCD-43PT"
000003  000008  */
000004  000009      #constant uLCD_43PT_GFX2
000005  000009      #constant uLCD_43PT_GFX2
000006  000010        
000007  000011      #IFNOT EXISTS PICASO_FUNCTIONS
file C:\Program Files (x86)\4D Labs\4D Workshop 4 IDE\include\PicasoFunctions.fnc

000008  000012          #inherit "PicasoFunctions.fnc"        // inherit the generic functions
000009  000012          #inherit "PicasoFunctions.fnc"        // inherit the generic functions
000010  000001        
000011  000002  // Common inheritance for PicasoGFX2 platforms
000012  000003        
000013  000004  #constant PICASO_FUNCTIONS
000014  000004  #constant PICASO_FUNCTIONS
000015  000005        
000016  000006        
000017  000007  #CONST
000018  000017  #END
000019  000018        
000020  000019  #CONST
000021  000025  #END
000022  000026        
000023  000027        
000024  000028  #CONST
000025  000040  #END
000026  000041        
000027  000042        
000028  000043  #CONST
000029  000208  #END
000030  000209        
000031  000210        
000032  000211  // baud divisor rates for setbaud(n);
000033  000212  #CONST
000034  000234  #END
000035  000235        
000036  000236        
000037  000237        
000038  000238        
000039  000243  */
000040  000244        
000041  000245        
000042  000246  //==============================================//
000043  000247  // EVE bios functions                           //
000044  000248  //==============================================//
000045  000249                                                  //
000046  000250  func serin(), 1;                // read a byte from COM0
000047  000251  // Syntax: serin();
000048  000252  // Usage : char := serin();
000049  000253  // Notes : Receives a character from the Serial Port COM0. The transmission format is:
000050  000254  //     : No Parity, 1 Stop Bit, 8 Data Bits (N,8,1).
000051  000255  //     : The default Baud Rate is 115,200 bits per second or 115,200 baud. The baud rate can be
000052  000256  //     : changed under program control by using the setbaud(...) or the com_SetBaud(...) function.
000053  000257  //     : Returns: -1 if no character is available
000054  000258  //     : Returns: -2 if a framing error or over-run has occurred (auto cleared)
000055  000259  //     : Returns: positive value 0 to 255 for a valid character received
000056  000260        
000057  000261  func putch("char"), 0;                // write single char to current output device
000058  000262  // Syntax: putch("char");
000059  000263  // Usage : putch("A");
000060  000264  // Notes : Transmits a single byte from the Serial Port COM0. The transmission format is:
000061  000265  //     : No Parity, 1 Stop Bit, 8 Data Bits (N,8,1).
000062  000266  //     : The default Baud Rate is 115,200 bits per second or 115,200 baud. The baud rate can be
000063  000267  //     : changed under program control by using the setbaud(...) or the com_SetBaud(...) function.
000064  000268  //     : The arguments can be a variable, array element, expression or constant
000065  000269        
000066  000270  func serout("char"), 0;                // write a byte to COM0
000067  000271  // Syntax: serout1("char");
000068  000272  // Usage : serout1(ch);
000069  000273  // Notes : send character to COM1
000070  000274        
000071  000275  func setbaud("baudnum"), 0;            // set baud rate of COM0
000072  000276  // Syntax: setbaud(baud_number);
000073  000277  // Usage : setbaud(BAUD_128000);        //Set baud rate to 128000bps
000074  000278  // *Notes : argument specifies the baud rate using pre-defined constant.
000075  000279  //       : The pre-defined constant is a value of 0-19 , and internally
000076  000280  //       : this is used as a table pointer to get the baud rate divisor
000077  000281  //       : value for one of the 20 selected baud rates, control is then
000078  000282  //       : passed to com_SetBaud(COM0, baudlookup[baud_number]);
000079  000283  //       : The pre-defined constants equate to a value of 0-19.
000080  000284  //       : If a value other than 0-19 is used, a run time error (eror 25)
000081  000285  //       : will occur.
000082  000286        
000083  000287  func to("device"), 1;                // output device redirection
000084  000288  // Syntax: to(outstream);
000085  000289  // Usage : to(APPEND); putstr("TWO ");
000086  000290  // Notes : outstream: A variable or constant specifying destination for putch, putstr, putnum and print functions.
000087  000291  //     :
000088  000292  //     : to() sends the printed output to destinations other than the screen. Normally, print just
000089  000293  //     : sends its output to the display in TEXT mode which is the default, however, the output from
000090  000294  //     : print can be sent to COM0, and MDA (media) 'streams'. The to(...) function can also stream
000091  000295  //     : to a memory array . Note that once the to(...) function has taken effect, the stream reverts
000092  000296  //     : back to the default stream which is TEXT as soon as putch, putstr, putnum or print has
000093  000297  //     : completed its action. The APPEND argument is used to send the printed output to the same
000094  000298  //     : place as the previous redirection. This is most useful for building string arrays, or adding
000095  000299  //     : sequential data to a media stream.
000096  000300  //     :
000097  000301  //     : Predefined Name Constant    putch(), putstr(), putnum(), print() redirection
000098  000302  //     : APPEND         0x0000      Output is directed to the same stream that was previously assigned. Output is
000099  000303  //     :                            appended to user memory if previous redirection was to an array.
000100  000304  //     : COM0           0xFF04      Output is redirected to the COM (serial) port.
000101  000305  //     : TEXT           0xFF08      Output is directed to the screen (default).
000102  000306  //     : MDA            0xFF10      Output is directed to the SD or FLASH media.
000103  000307  //     : I2C            0xF820      Output is directed to the I2C port.
000104  000308  //     : memory pointer             Output is redirect to the memory pointer argument, eg to(myarray); print("HELLO");
000105  000309        
000106  000310        
000107  000311  func pause("milliseconds"), 0;            // blocking delay
000108  000312  // Syntax: pause(milliseconds);
000109  000313  // Usage : pause(1000);                //pause for 1 second
000110  000314  // Notes : Pause for a number of milli second.Maximum delay could be 65535 milli seconds
000111  000315        
000112  000316  func putnum("arg1","arg2"), 1;            // print number to current output device
000113  000317  // Syntax: putnum(format, value);
000114  000318  // Usage : var := putnum(HEX, val);
000115  000319  // Notes : prints a 16bit number in various formats to the current output stream, usually the display.
000116  000320  //     : Format: A constant that specifies the number format
000117  000321  //     : Value : The number to be printed
000118  000322  //     : (      DECIMAL   )    (   UNSIGNED DECIMAL )    (    HEX         )     (    BINARY          )
000119  000323  //     : DEC     DECZ     DECZB     UDEC     UDECZ     UDECZB     HEX     HEXZ     HEXZB     BIN     BINZ     BINZB
000120  000324  //     : DEC1 DEC1Z     DEC1ZB     UDEC1     UDEC1Z     UDEC1ZB HEX1     HEX1Z     HEX1ZB     BIN1     BIN1Z     BIN1ZB
000121  000325  //     : DEC2 DEC2Z     DEC2ZB     UDEC2     UDEC2Z     UDEC2ZB HEX2     HEX2Z     HEX1ZB     BIN2     BIN2Z     BIN2ZB
000122  000326  //     : DEC3 DEC3Z     DEC3ZB     UDEC3     UDEC3Z     UDEC3ZB HEX3     HEX3Z     HEX1ZB     BIN3     BIN3Z     BIN3ZB
000123  000327  //     : DEC4 DEC4Z     DEC4ZB     UDEC4     UDEC4Z     UDEC4ZB HEX4     HEX4Z     HEX1ZB     BIN4     BIN4Z     BIN4ZB
000124  000328  //     : DEC5 DEC5Z     DEC5ZB     UDEC5     UDEC5Z     UDEC5ZB             BIN5     BIN5Z     BIN5ZB
000125  000329  //     :                                     BIN6     BIN6Z     BIN6ZB
000126  000330  //     :                                     BIN7     BIN7Z     BIN7ZB
000127  000331  //     :                                     BIN8     BIN8Z     BIN8ZB
000128  000332  //     :                                     BIN9     BIN9Z     BIN9ZB
000129  000333  //     :                                     BIN10     BIN10Z     BIN10ZB
000130  000334  //     :                                     BIN11     BIN11Z     BIN11ZB
000131  000335  //     :                                     BIN12     BIN12Z     BIN12ZB
000132  000336  //     :                                     BIN13     BIN13Z     BIN13ZB
000133  000337  //     :                                     BIN14     BIN14Z     BIN14ZB
000134  000338  //     :                                     BIN15     BIN15Z     BIN15ZB
000135  000339  //     :                                     BIN16     BIN16Z     BIN16ZB
000136  000340  //     : field: Returns the the default width of the numeric field (digit count), usually ignored.
000137  000341  //     : bit 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
000138  000342  //     : | | | | \___ ___/ \__ __/ \_____ _____/
000139  000343  //     : | | | | V V V
000140  000344  //     : | | | | | | |
000141  000345  //     : | | | | | |
000142  000346  //     : | | | | (nb 0 = 16) | |____BASE (usually 2,10 or 16)
000143  000347  //     : | | | | digit count |
000144  000348  //     : | | | | |___reserved (not used on GOLDELOX)
000145  000349  //     : | | | |
000146  000350  //     : | | | |
000147  000351  //     : | | | |
000148  000352  //     : | | | |
000149  000353  //     : | | | |
000150  000354  //     : | | | |______ 1 = leading zeros included
000151  000355  //     : | | | 0 = leading zeros suppressed
000152  000356  //     : | | |
000153  000357  //     : | | |
000154  000358  //     : | | |_______ 1 = leading zero blanking
000155  000359  //     : | |
000156  000360  //     : | |_____ sign bit (0 = signed, 1 = unsigned)
000157  000361  //     : |
000158  000362  //     : |______ 1 = space before unsigned number
000159  000363        
000160  000364        
000161  000365  func translate("arg1","arg2","arg3","arg4"), 1; // list translator (internal use only, not usable)
000162  000366        
000163  000367  func putstr("string"), 1;                       // print string to current output device
000164  000368  // Syntax: putstr(pointer);
000165  000369  // Usage : putstr("HELLO\n");
000166  000370  // Notes : putstr prints a string to the current output stream, usually the display. The argument can be
000167  000371  //       : a string constant, a word aligned pointer to a string, a pointer to an array, or a pointer to
000168  000372  //       : a data statement. Note that string constants and data statement pointers are byte aligned.
000169  000373  //       : The output of putstr can be redirected to the communications port, the media, or memory
000170  000374  //       : using the to(...); function.
000171  000375  //       : A string constant is automatically terminated with a zero.
000172  000376  //       : A string in a data statement is not automatically terminated with a zero.
000173  000377  //       : All variables in 4DGL are 16bit, if an array is used for holding 8 bit characters, each array
000174  000378  //       : element packs 1 or 2 characters.
000175  000379        
000176  000380        
000177  000381  func strlen("varAddress"), 1;                   // return length of a var packed string in character units
000178  000382  // Syntax: strlen("varAddress);
000179  000383  // Usage : strlen("HELLO\n");
000180  000384  // Notes : gives the length of a string that is packed into regular var array
000181  000385  //       : Use str_Length(ptr)  for string pointer mode
000182  000386        
000183  000387        
000184  000388  //==============================================//
000185  000389  // Memory Access Function Prototypes            //
000186  000390  //==============================================//
000187  000391                                                  //
000188  000392  func peekW("address"), 1;                       // read a word from system memory
000189  000393  func pokeW("address", "wordvalue"), 0;          // write a word to system memory
000190  000394  // refer to address map of internal variables   //
000191  000395  //==============================================//
000192  000396  // Math Functions                               //
000193  000397  //==============================================//
000194  000398                                                  //
000195  000399  func ABS("value"), 1;                           // return a positive number
000196  000400  // Syntax: ABS(value);
000197  000401  // Usage : var := ABS(arg);
000198  000402  // Notes : Returns the absolute value of an argument
000199  000403        
000200  000404  func MIN("value1", "value2"), 1;                // return the smaller of 2 numbers
000201  000405  // Syntax: MIN(value1, value2);
000202  000406  // Usage : var := MIN(arg1, arg2);
000203  000407  // Notes : Returns the minimum of 2 arguments
000204  000408        
000205  000409  func MAX("value1", "value2"), 1;                // return the larger of 2 numbers
000206  000410  // Syntax: MAX(value1, value2);
000207  000411  // Usage : var := MAX(arg1, arg2);
000208  000412  // Notes : Returns the maximum of 2 arguments
000209  000413        
000210  000414  func SWAP("&var", "&var"), 0;                   // swap 2 variables, arguments must point to variables
000211  000415  // Syntax: SWAP(&var1, &var2);
000212  000416  // Usage : SWAP(&var1, &var2);
000213  000417  // Notes : Swaps the contents of 2 variables or memory locations
000214  000418        
000215  000419  func SIN("angle"), 1;                           // return SIN of angle
000216  000420  // Syntax: SIN(angle);
000217  000421  // Usage : var := SIN(arg);
000218  000422  // Notes : Returns the sine in radians of an argument in degrees
000219  000423  //       : the returned value range is from 127 to -127. The real
000220  000424  //       : cosine values vary from 1.0 to -1.0 so appropriate
000221  000425  //       : scaling must be done in user code.
000222  000426        
000223  000427  func COS("angle"), 1;                           // return COS of angle
000224  000428  // Syntax: COS(angle);
000225  000429  // Usage : var := COS(arg);
000226  000430  // Notes : Returns the cosine in radians of an argument in degrees
000227  000431  //       : the returned value range is from 127 to -127. The real
000228  000432  //       : cosine values vary from 1.0 to -1.0 so appropriate
000229  000433  //       : scaling must be done in user code.
000230  000434        
000231  000435  func RAND(), 1;                                 // return a pseudo random number
000232  000436  // Syntax: RAND();
000233  000437  // Usage : var := RAND();
000234  000438  // Notes : Returns a random number between 0 and 0xFFFF.
000235  000439  //       : The random number generator must first be seeded
000236  000440  //       : by using the SEED(number) function.
000237  000441        
000238  000442  func SEED("number"), 0;                         // re-seed the pseudo random number generator
000239  000443  // Syntax: SEED(number);
000240  000444  // Usage : SEED(arg);
000241  000445  // Notes : Seeds the random number generator.
000242  000446        
000243  000447  func OVF(), 1;                                  // returns upper 16bits of 32bit results
000244  000448  // Syntax: OVF();
000245  000449  // Usage : loWord := 0x2710 * 0x2710;           // (10000 * 10000 in hex format)
000246  000450  //       : hiWord := OVF();
000247  000451  // Notes : This function returns the high order 16 bits from certain math and shift functions..
000248  000452        
000249  000453  func SQRT("number"), 1;                         // return square root of a number
000250  000454  // Syntax: SQRT(number);
000251  000455  // Usage : SQRT(arg);
000252  000456  // Notes : Returns the integer square root of a number.
000253  000457  //------------------------------------------------------------------//
000254  000458  //          Text Related Function Prototypes
000255  000459  //------------------------------------------------------------------//
000256  000460        
000257  000461  func txt_MoveCursor("line", "column"), 0;
000258  000462  // Syntax: txt_SetCursor(line, column);
000259  000463  // Usage : txt_SetCursor(arg1, arg2);
000260  000464  // Notes : Moves the text Cursor to a new screen position set by
000261  000465  //       : line,column parameters.
000262  000466        
000263  000467  func txt_Set("mode", "value"), 0;
000264  000468  // Syntax: txt_Set(mode, value);
000265  000469  // Usage : txt_Set(arg1, arg2);
000266  000470  // Returns : Original value before the change
000267  000471  // Notes : Sets various text related parameters used by other functions
000268  000472  //       : This allows the features to be set programatically with a
000269  000473  //       : single function call.It is strongly recommended to use the
000270  000474  //       : pre-defined constants rather than the mode numbers.
000271  000475  //       : NB:- Although it is often required to be able to set text
000272  000476  //       : functions with a single function call for graphics engine
000273  000477  //       : related functions, there is a complete set of single parameter
000274  000478  //       : shortcut functions that have exactly the same function as
000275  000479  //       : each of the txt_Set modes and saves 1 parameter / uses less memory
000276  000480  //       :
000277  000481  //       : mode = TEXT_COLOUR (mode 0)
000278  000482  //       : txt_Set(TEXT_COLOUR, value);
000279  000483  //       : value = 0 to 0xFFFF, Black to White
000280  000484  //       : Sets the Text colour for the display
000281  000485  //       : Default = LIME.
000282  000486  //       :
000283  000487  //       : mode = TEXT_HIGHLIGHT (mode 1)
000284  000488  //       : txt_Set(TEXT_HIGHLIGHT, value);
000285  000489  //       : value = 0 to 0xFFFF, Black to White
000286  000490  //       : Sets the Text background colour for the display. Effective
000287  000491  //       : when text mode is Opaque.
000288  000492  //       : Default = BLACK.
000289  000493  //       :
000290  000494  //       : mode = FONT_ID (mode 2)
000291  000495  //       : txt_Set(FONT_ID, value);
000292  000496  //       : value = FONT1, FONT2 or FONT3 for internal fonts
000293  000497  //       : else this value is the name of a font included
000294  000498  //       : in a users program in a data statement.
000295  000499  //       : Default = FONT SIZE 3.
000296  000500  //       :
000297  000501  //       : mode = TEXT_WIDTH  (mode 3)
000298  000502  //       : txt_Set(TEXT_WIDTH, value);
000299  000503  //       : value = 1 to 16
000300  000504  //       : Sets the Text Width multiplier
000301  000505  //       : text will be printed magnified horizontally
000302  000506  //       : by this factor, Default = 1.
000303  000507  //       :
000304  000508  //       : mode = TEXT_HEIGHT  (mode 4)
000305  000509  //       : txt_Set(TEXT_HEIGHT, value);
000306  000510  //       : value = 1 to 16
000307  000511  //       : Sets the Text Height multiplier
000308  000512  //       : text will be printed magnified vertically
000309  000513  //       : by this factor, Default = 1.
000310  000514  //       :
000311  000515  //       : mode = TEXT_XGAP  (mode 5)
000312  000516  //       : txt_Set(TEXT_XGAP, value);
000313  000517  //       : value = 1 to 32
000314  000518  //       : Sets the horizontal gap between characters
000315  000519  //       : The gap is in pixel units, Default = 0
000316  000520  //       :
000317  000521  //       : mode = TEXT_YGAP  (mode 6)
000318  000522  //       : txt_Set(TEXT_YGAP, value);
000319  000523  //       : value = 1 to 32
000320  000524  //       : Sets the vertical gap below characters
000321  000525  //       : The gap is in pixel units, Default = 0
000322  000526  //       :
000323  000527  //       : mode = TEXT_PRINTDELAY  (mode 7) DEPRECATED
000324  000528  //       : txt_Set(TEXT_PRINTDELAY, value);
000325  000529  //       : value = 0 to 255
000326  000530  //       : Sets the delay time (in ms) during character
000327  000531  //       : printing to give a 'teletype' like effect.
000328  000532  //       : Often used to attract attention to a string
000329  000533  //       : being printed which can often be missed if
000330  000534  //       : just suddenly appearing or changing.
000331  000535  //       : Default = 0 ms.
000332  000536  //       :
000333  000537  //       : mode = TEXT_OPACITY (mode 8)
000334  000538  //       : txt_Set(TEXT_OPACITY, value);
000335  000539  //       : value = TRANSPARENT (0) = Text Trasparent
000336  000540  //       : value = OPAQUE (1) = Text Opaque
000337  000541  //       : Sets the Opacity/Transparency of the text
000338  000542  //       : Default = 0 or TRANSPARENT
000339  000543  //       :
000340  000544  //       : mode = TEXT_BOLD (mode 9)
000341  000545  //       : txt_Set(TEXT_BOLD, value);
000342  000546  //       : value = dont care
000343  000547  //       : Sets Bold Text mode for the next string or char
000344  000548  //       : The feature automatically resets after printing
000345  000549  //       : using putstr or print has completed
000346  000550  //       :
000347  000551  //       : mode = TEXT_ITALIC (mode 10)
000348  000552  //       : txt_Set(TEXT_ITALIC, value);
000349  000553  //       : value = dont care
000350  000554  //       : Sets Italic Text mode for the next string or char
000351  000555  //       : The feature automatically resets after printing
000352  000556  //       : using putstr or print has completed
000353  000557        
000354  000558  //       : mode = TEXT_INVERSE (mode 11)
000355  000559  //       : txt_Set(TEXT_INVERSE, value);
000356  000560  //       : value = dont care
000357  000561  //       : Sets Inverse Text mode for the next string or char
000358  000562  //       : The feature automatically resets after printing
000359  000563  //       : using putstr or print has completed
000360  000564  //       :
000361  000565  //       : mode = TEXT_UNDERLINED (mode 12)
000362  000566  //       : txt_Set(TEXT_UNDERLINED, value);
000363  000567  //       : value = dont care
000364  000568  //       : Sets Underlined Text mode for the next string or char
000365  000569  //       : The feature automatically resets after printing
000366  000570  //       : using putstr or print has completed
000367  000571  //       :
000368  000572  //       : mode = TEXT_ATTRIBUTES (mode 13)
000369  000573  //       : txt_Set(TEXT_ATTRIBUTES, value);
000370  000574  //       : value = bits are defined as:
000371  000575  //       :  BOLD        16          // TEXT_ATTRIBUTES bold text (auto reset)
000372  000576  //       :  ITALIC      32          // TEXT_ATTRIBUTES italic text (auto reset)
000373  000577  //       :  INVERSE     64          // TEXT_ATTRIBUTES inverse text (auto reset)
000374  000578  //       :  UNDERLINED  128         // TEXT_ATTRIBUTES underlined text (auto reset)
000375  000579  //       : Allows a combination of text attributes to be defined together
000376  000580  //       : by 'or'ing the bits together.
000377  000581  //       : Example: txt_Set(TEXT_ATTRIBUTES, BOLD | INVERSE); // bold + inverse
000378  000582  //       : The feature automatically resets after printing
000379  000583  //       : using putstr or print has completed.
000380  000584  //       : Bits 0-3 and 8-15 are reserved for future attributes.
000381  000585  //       :
000382  000586  //       : mode = TEXT_WRAP (mode 14)
000383  000587  //       : txt_Set(TEXT_WRAP , value);
000384  000588  //       : Sets the position where text wrap will occur
000385  000589  //       : The feature automatically resets when screen
000386  000590  //       : mode is changed. If the value is set to 0,
000387  000591  //       : text wrap is turned off.
000388  000592  //       : of the current screen. Default value is 0
000389  000593  // Notes : The value is in pixel units.
000390  000594  //       :
000391  000595        
000392  000596  //       : txt_Set mode 15 reserved for future use
000393  000597  //       :
000394  000598        
000395  000599        
000396  000600        
000397  000601  //=====================================================//
000398  000602  // Single parameter short-cuts                         //
000399  000603  // for the txt_Set functions                           //
000400  000604  // These functions return the existing value before    //
000401  000605  // the change is made.                                 //
000402  000606  //=====================================================//
000403  000607  func txt_FGcolour("colour"), 1;             // 0  text foreground colour
000404  000608  func txt_BGcolour("colour"), 1;             // 1  text background colour
000405  000609  func txt_FontID("id"), 1;                   // 2  text font ID (0 = system font)
000406  000610  func txt_Width("multiplier"), 1;            // 3  text width multiplier
000407  000611  func txt_Height("multiplier"), 1;           // 4  text height multiplier
000408  000612  func txt_Xgap("pixelcount"), 1;             // 5  text gap between characters
000409  000613  func txt_Ygap("pixelcount"), 1;             // 6  text gap between lines
000410  000614  func txt_Delay("millisecs"), 1;             // 7  text printing delay factor
000411  000615  func txt_Opacity("mode"), 1;                // 8  text OPAQUE or TRANSPARENT
000412  000616  func txt_Bold("mode"), 1;                   // 9  text bold ON/OFF
000413  000617  func txt_Italic("mode"), 1;                 // 10 text italic ON/OFF
000414  000618  func txt_Inverse("mode"), 1;                // 11 text inverse ON/OFF
000415  000619  func txt_Underline("mode"), 1;              // 12 text underline ON/OFF
000416  000620  func txt_Attributes("value"), 1;            // 13 text combined bold|italic|inverse|underline
000417  000621  func txt_Wrap("value"), 1;                  // 14 text set text wrap position
000418  000622  func _1F(), 0;                              // 15 text (reserved DO NOT REMOVE)
000419  000623        
000420  000624        
000421  000625  //------------------------------------------------------------------//
000422  000626  //                 Hardware Function Prototypes
000423  000627  //------------------------------------------------------------------//
000424  000628        
000425  000629  // I/O Pin reference:-
000426  000630  //
000427  000631  //    IO1_PIN           is pin 2 of J1
000428  000632  //    IO2_PIN           is pin 1 of J1
000429  000633  //    IO3_PIN           is pin 3 of J1
000430  000634  //    IO4_PIN           is pin 5 of J1 (also used for BUS_RD)
000431  000635  //    IO5_PIN           is pin 9 of J2 (also used for BUS_WR)
000432  000636  //    BUS_RD_PIN        is pin 5 of J1 (alias IO4_PIN)
000433  000637  //    BUS_WR_PIN        is pin 9 of J2 (alias IO5_PIN)
000434  000638  //    BUS_0             is pin 27 of J1
000435  000639  //    BUS_1             is pin 25 of J1
000436  000640  //    BUS_2             is pin 23 of J1
000437  000641  //    BUS_3             is pin 21 of J1
000438  000642  //    BUS_4             is pin 19 of J1
000439  000643  //    BUS_5             is pin 17 of J1
000440  000644  //    BUS_6             is pin 13 of J2
000441  000645  //    BUS_7             is pin 11 of J2
000442  000646  //    BACKLITE          is backlite control pin
000443  000647  //    AUDIO_ENABLE      is amplifier chip control pin
000444  000648        
000445  000649  func pin_Set("mode", "pin"), 1;            // set pin to required mode
000446  000650  // Syntax: pin_Set(mode, pin);
000447  000651  // Usage : pin_Set(arg1, arg2);
000448  000652  // Notes : Sets the appropriate pins to Inputs or Outputs
000449  000653  //       : returns true if the pin number is legal (usually ignored)
000450  000654  //       :
000451  000655  //       : mode = 0 : Set Pin to Output
000452  000656  //       : pin_Set(0, pin);
000453  000657  //       : pin_Set(OUTPUT, pin);
000454  000658  //       : pin = 1  : set IO1_PIN to output (pin 2 J1)
000455  000659  //       : pin = 2  : set IO2_PIN to output (pin 1 J1)
000456  000660  //       : pin = 3  : set IO3_PIN to output (pin 3 J1)
000457  000661  //       : pin = 4  : set IO4_PIN to output (pin 5 J1, also used for BUS_RD)
000458  000662  //       : pin = 5  : set IO5_PIN to output (pin 9 J2, also used for BUS_WR)
000459  000663  //       : (pin 6,7 are BACKLITE and AMP control and are permanemtly outputs which can't be altered)
000460  000664  //       : pin = 8  : set BUS_0   to output (pin 27 of J1)
000461  000665  //       : pin = 9  : set BUS_1   to output (pin 25 of J1)
000462  000666  //       : pin = 10 : set BUS_2   to output (pin 23 of J1)
000463  000667  //       : pin = 11 : set BUS_3   to output (pin 21 of J1)
000464  000668  //       : pin = 12 : set BUS_4   to output (pin 19 of J1)
000465  000669  //       : pin = 13 : set BUS_5   to output (pin 17 of J1)
000466  000670  //       : pin = 14 : set BUS_6   to output (pin 13 of J2)
000467  000671  //       : pin = 15 : set BUS_7   to output (pin 11 of J2)
000468  000672  //       : Sets the desired pin to be used as an Output.
000469  000673  //       :
000470  000674  //       : mode = 1 : Set Pin to Input
000471  000675  //       : pin_Set(1, pin);
000472  000676  //       : pin_Set(INPUT, pin);
000473  000677  //       : pin = 1  : set IO1_PIN to input (pin 2 J1)
000474  000678  //       : pin = 2  : set IO2_PIN to input (pin 1 J1)
000475  000679  //       : pin = 3  : set IO3_PIN to input (pin 3 J1)
000476  000680  //       : pin = 4  : set IO4_PIN to input (pin 5 J1, also used for BUS_RD)
000477  000681  //       : pin = 5  : set IO5_PIN to input (pin 9 J2, also used for BUS_WR)
000478  000682  //       : (pin 6,7 are BACKLITE and AMP control and are permanemtly outputs which can't be altered)
000479  000683  //       : pin = 8  : set BUS_0   to input (pin 27 of J1)
000480  000684  //       : pin = 9  : set BUS_1   to input (pin 25 of J1)
000481  000685  //       : pin = 10 : set BUS_2   to input (pin 23 of J1)
000482  000686  //       : pin = 11 : set BUS_3   to input (pin 21 of J1)
000483  000687  //       : pin = 12 : set BUS_4   to input (pin 19 of J1)
000484  000688  //       : pin = 13 : set BUS_5   to input (pin 17 of J1)
000485  000689  //       : pin = 14 : set BUS_6   to input (pin 13 of J2)
000486  000690  //       : pin = 15 : set BUS_7   to input (pin 11 of J2)
000487  000691  //       : Sets the desired pin to be used as an Input.
000488  000692        
000489  000693  func pin_HI("pin"), 1;                    // set pin to logic '1'
000490  000694  // Syntax: pin_HI(pin);
000491  000695  // Usage : pin_HI(arg);
000492  000696  // Notes : Outputs a logic "High" (3.3V) on the appropriate
000493  000697  //       : pin that was previously selected as an Output.
000494  000698  //       : returns true if the pin number is legal (usually ignored)
000495  000699  //       :
000496  000700  //       : pin = 1  : set IO1_PIN to "High" level (pin 2 of J1)
000497  000701  //       : pin = 2  : set IO2_PIN to "High" level (pin 1 of J1)
000498  000702  //       : pin = 3  : set IO3_PIN to "High" level (pin 3 of J1)
000499  000703  //       : pin = 4  : set IO4_PIN to "High" level (pin 5 of J1, also used for BUS_RD)
000500  000704  //       : pin = 5  : set IO5_PIN to "High" level (pin 9 of J2, also used for BUS_WR)
000501  000705  //       : pin = 6  : set DCENB pin to "High" level (BACKLITE ON)
000502  000706  //       : pin = 7  : set AUDIO_ENABL pin to "High" level (AMP OFF)
000503  000707  //       : pin = 8  : set BUS_0   to "High" level (pin 27 of J1)
000504  000708  //       : pin = 9  : set BUS_1   to "High" level (pin 25 of J1)
000505  000709  //       : pin = 10 : set BUS_2   to "High" level (pin 23 of J1)
000506  000710  //       : pin = 11 : set BUS_3   to "High" level (pin 21 of J1)
000507  000711  //       : pin = 12 : set BUS_4   to "High" level (pin 19 of J1)
000508  000712  //       : pin = 13 : set BUS_5   to "High" level (pin 17 of J1)
000509  000713  //       : pin = 14 : set BUS_6   to "High" level (pin 13 of J2)
000510  000714  //       : pin = 15 : set BUS_7   to "High" level (pin 11 of J2)
000511  000715        
000512  000716  func pin_LO("pin"), 1;                    // set pin to logic '0'
000513  000717  // Syntax: pin_LO(pin);
000514  000718  // Usage : pin_LO(arg);
000515  000719  // Notes : Outputs a logic "Low" (0V) on the appropriate
000516  000720  //       : pin that was previously selected as an Output.
000517  000721  //       : returns true if the pin number is legal (usually ignored)
000518  000722  //       :
000519  000723  //       : pin = 1 : set IO1_PIN to "Low" level (pin 2 of J1)
000520  000724  //       : pin = 2 : set IO2_PIN to "Low" level (pin 1 of J1)
000521  000725  //       : pin = 3 : set IO3_PIN to "Low" level (pin 3 of J1)
000522  000726  //       : pin = 4 : set IO4_PIN to "Low" level (pin 5 of J1, also used for BUS_RD)
000523  000727  //       : pin = 5 : set IO5_PIN to "Low" level (pin 9 of J2, also used for BUS_WR)
000524  000728  //       : pin = 6 : set DCENB pin to "Low" level (BACKLITE)
000525  000729  //       : pin = 7 : set AUDIO_ENABL pin to "Low" level (AMP ON)
000526  000730  //       : pin = 8  : set BUS_0  to "Low" level (pin 27 of J1)
000527  000731  //       : pin = 9  : set BUS_1  to "Low" level (pin 25 of J1)
000528  000732  //       : pin = 10 : set BUS_2  to "Low" level (pin 23 of J1)
000529  000733  //       : pin = 11 : set BUS_3  to "Low" level (pin 21 of J1)
000530  000734  //       : pin = 12 : set BUS_4  to "Low" level (pin 19 of J1)
000531  000735  //       : pin = 13 : set BUS_5  to "Low" level (pin 17 of J1)
000532  000736  //       : pin = 14 : set BUS_6  to "Low" level (pin 13 of J2)
000533  000737  //       : pin = 15 : set BUS_7  to "Low" level (pin 11 of J2)
000534  000738        
000535  000739  func pin_Read("pin"), 1;                // read pin, logic or analogue
000536  000740  // Syntax: pin_Read(pin);
000537  000741  // Usage : arg1 := pin_Read(arg2);
000538  000742  // Notes : Reads the logic state of the appropriate
000539  000743  //       : pin that was previously selected as an Input.
000540  000744  //       :
000541  000745  //       : pin = 1  : Read the state of IO1_PIN (pin 2 of J1)
000542  000746  //       : pin = 2  : Read the state of IO2_PIN (pin 1 of J1)
000543  000747  //       : pin = 3  : Read the state of IO3_PIN (pin 3 of J1)
000544  000748  //       : pin = 4  : Read the state of IO4_PIN (pin 5 of J1, also used for BUS_RD)
000545  000749  //       : pin = 5  : Read the state of IO5_PIN (pin 9 of J2, also used for BUS_WR)
000546  000750  //       : pin = 6  : Read the state of DCENB pin to "Low" level (BACKLITE)
000547  000751  //       : pin = 7  : Read the state of AUDIO_ENABL pin to "Low" level (AMP ON)
000548  000752  //       : pin = 8  : Read the state of BUS_0   (pin 27 of J1)
000549  000753  //       : pin = 9  : Read the state of BUS_1   (pin 25 of J1)
000550  000754  //       : pin = 10 : Read the state of BUS_2   (pin 23 of J1)
000551  000755  //       : pin = 11 : Read the state of BUS_3   (pin 21 of J1)
000552  000756  //       : pin = 12 : Read the state of BUS_4   (pin 19 of J1)
000553  000757  //       : pin = 13 : Read the state of BUS_5   (pin 17 of J1)
000554  000758  //       : pin = 14 : Read the state of BUS_6   (pin 13 of J2)
000555  000759  //       : pin = 15 : Read the state of BUS_7   (pin 11 of J2)
000556  000760  //       : Returns a 0 (logic low) or 1 (logic high).
000557  000761        
000558  000762        
000559  000763  //------------------------------------------------------------------//
000560  000764  //                 P1 module BUS I/O control
000561  000765  //------------------------------------------------------------------//
000562  000766        
000563  000767  func bus_In(), 1;
000564  000768  // Syntax: bus_In();
000565  000769  // Usage : arg1 := bus_In();
000566  000770  // Notes : Read the 8bit wide bus into the lower 8 bits of arg1.
000567  000771  //       : The upper 8 bits of arg1 are set to 0.
000568  000772  //       : the BUS_RD and BUS_WR pins are not affected.
000569  000773  //       :
000570  000774  //       : BUS_0 is pin 27 of J1
000571  000775  //       : BUS_1 is pin 25 of J1
000572  000776  //       : BUS_2 is pin 23 of J1
000573  000777  //       : BUS_3 is pin 21 of J1
000574  000778  //       : BUS_4 is pin 19 of J1
000575  000779  //       : BUS_5 is pin 17 of J1
000576  000780  //       : BUS_6 is pin 13 of J2
000577  000781  //       : BUS_7 is pin 11 of J2
000578  000782        
000579  000783  func bus_Out("var"), 0;
000580  000784  // Syntax: bus_Out(var);
000581  000785  // Usage : bus_Out(arg1);
000582  000786  // Notes : The lower 8 bits of arg1 are placed on the 8bit wide bus.
000583  000787  //       : The upper 8 bits of arg1 are ignored.
000584  000788  //       : the BUS_RD and BUS_WR pins are not affected.
000585  000789  //       : NB:- any BUS pins that are set to inputs are not affected.
000586  000790  //       :
000587  000791  //       : BUS_0 is pin 27 of J1
000588  000792  //       : BUS_1 is pin 25 of J1
000589  000793  //       : BUS_2 is pin 23 of J1
000590  000794  //       : BUS_3 is pin 21 of J1
000591  000795  //       : BUS_4 is pin 19 of J1
000592  000796  //       : BUS_5 is pin 17 of J1
000593  000797  //       : BUS_6 is pin 13 of J2
000594  000798  //       : BUS_7 is pin 11 of J2
000595  000799        
000596  000800  func bus_Set("var"), 0;
000597  000801  // Syntax: bus_Set(var);
000598  000802  // Usage : bus_Set(arg1);
000599  000803  // Notes : The lower 8 bits of arg1 are placed in the BUS direction register.
000600  000804  //       : a '1' sets a pin to be an input, a '0' sets a pin to be output.
000601  000805  //       : The upper 8 bits of arg1 are ignored.
000602  000806  //       : the BUS_RD and BUS_WR pins are not affected.
000603  000807  //       :
000604  000808  //       : BUS_0 is pin 27 of J1
000605  000809  //       : BUS_1 is pin 25 of J1
000606  000810  //       : BUS_2 is pin 23 of J1
000607  000811  //       : BUS_3 is pin 21 of J1
000608  000812  //       : BUS_4 is pin 19 of J1
000609  000813  //       : BUS_5 is pin 17 of J1
000610  000814  //       : BUS_6 is pin 13 of J2
000611  000815  //       : BUS_7 is pin 11 of J2
000612  000816        
000613  000817  func bus_Write("var"), 0;
000614  000818  // Syntax: bus_Write(var);
000615  000819  // Usage : bus_Write(arg1);
000616  000820  // Notes : The lower 8 bits of arg1 are placed on the BUS, then, after
000617  000821  //       : a settling delay of approx 50nsec, the BUS_WR pin is strobed
000618  000822  //       : LO for approx 50nsec then set back HI.
000619  000823  //       : The upper 8 bits of arg1 are ignored.
000620  000824  //       : NB:- the BUS_WR pin is automatically pre-set to an output to
000621  000825  //       : ensure BUS write integrity.
000622  000826  //       :
000623  000827  //       : BUS_0 is pin 27 of J1
000624  000828  //       : BUS_1 is pin 25 of J1
000625  000829  //       : BUS_2 is pin 23 of J1
000626  000830  //       : BUS_3 is pin 21 of J1
000627  000831  //       : BUS_4 is pin 19 of J1
000628  000832  //       : BUS_5 is pin 17 of J1
000629  000833  //       : BUS_6 is pin 13 of J2
000630  000834  //       : BUS_7 is pin 11 of J2
000631  000835        
000632  000836  func bus_Read(), 1;
000633  000837  // Syntax: bus_Read();
000634  000838  // Usage : arg1 := bus_Read();
000635  000839  // Notes : The BUS_RD pin set to LO, then, after a settling delay
000636  000840  //       : of approx 50nsec, the BUS is read into the lower 8 bits of arg
000637  000841  //       : (the upper 8 bits being set to 0)
000638  000842  //       : the BUS_RD pin is then set back to a HI level.
000639  000843  //       : NB:- the BUS_RD pin is automatically pre-set to an output to
000640  000844  //       : ensure BUS write integrity.
000641  000845  //       :
000642  000846  //       : BUS_0 is pin 27 of J1
000643  000847  //       : BUS_1 is pin 25 of J1
000644  000848  //       : BUS_2 is pin 23 of J1
000645  000849  //       : BUS_3 is pin 21 of J1
000646  000850  //       : BUS_4 is pin 19 of J1
000647  000851  //       : BUS_5 is pin 17 of J1
000648  000852  //       : BUS_6 is pin 13 of J2
000649  000853  //       : BUS_7 is pin 11 of J2
000650  000854        
000651  000855        
000652  000856  //------------------------------------------------------------------//
000653  000857  //   Graphics Functions
000654  000858  //------------------------------------------------------------------//
000655  000859  func gfx_Set("mode", "value"), 0;            // set various graphics functions
000656  000860  // Syntax: gfx_Set(mode, value);
000657  000861  // Usage : gfx_Set(arg1, arg2);
000658  000862  // Notes : Sets various graphics parameters used by other functions
000659  000863  //       : This allows the features to be set programatically with a
000660  000864  //       : single function call.It is strongly recommended to use the
000661  000865  //       : pre-defined constants rather than the mode numbers.
000662  000866  //       : NB:- Although it is often required to be able to set graphics
000663  000867  //       : functions with a single function call for graphics engine
000664  000868  //       : related functions, there is a complete set of single parameter
000665  000869  //       : shortcut functions that have exactly the same function as
000666  000870  //       : each of the gfx_Set modes and saves 1 parameter / uses less memory
000667  000871  //       :
000668  000872  //       : mode = PEN_SIZE (mode 16)
000669  000873  //       : gfx_Set(PEN_SIZE, value);
000670  000874  //       : value = SOLID (value 0) rectangle and circle objects are solid
000671  000875  //       : value = OUTLINE (value 1) rectangle and circle objects are outlines
000672  000876  //       : Sets the mode of the Pen used by most graphics objects
000673  000877  //       :
000674  000878  //       : mode = BACKGROUND_COLOUR (mode 17)
000675  000879  //       : gfx_Set(BACKGROUND_COLOUR, value);
000676  000880  //       : value = 0 to 0xFFFF, Black to White
000677  000881  //       : Sets the Background colour of the screen
000678  000882  //       :
000679  000883  //       : mode = OBJECT_COLOUR (mode 18)
000680  000884  //       : gfx_Set(OBJECT_COLOUR, value);
000681  000885  //       : value = 0 to 0xFFFF, Black to White
000682  000886  //       : Sets the Object colour used in various functions
000683  000887  //       : LineTo(,,); LineRel(,,); BoxTo(,,); Dot(); etc.
000684  000888  //       :
000685  000889  //       : mode = CLIPPING (mode 19)
000686  000890  //       : gfx_Set(CLIPPING, value);
000687  000891  //       : value = OFF (value 0) Clipping disabled
000688  000892  //       : value = ON (value 1) Clipping enabled
000689  000893  //       : Enables/Disables the Clipping feature
000690  000894  //       :
000691  000895  //       : mode = TRANSPARENT_COLOUR (mode 20) : Image or Animation Transparency Colour.
000692  000896  //       : gfx_Set(TRANSPARENT_COLOUR, value);
000693  000897  //       : value = 0 to 0xFFFF Black to White
000694  000898  //       : Sets Bitmap, Image or Animation Transparency Colour.
000695  000899  //       : NB not implemented
000696  000900  //       :
000697  000901  //       : mode = TRANSPARENCY (mode 21) : Bitmap/Image/Animation Transparency
000698  000902  //       : gfx_Set(5, value);
000699  000903  //       : value = OFF (value 0) Transparency disabled
000700  000904  //       : value = ON (value 1) Transparency enabled
000701  000905  //       : Enables/Disables the Transparency feature
000702  000906  //       : NB not implemented
000703  000907  //       :
000704  000908  //       : mode = FRAME_DELAY (mode 22) : Inter-Frame Delay
000705  000909  //       : gfx_Set(FRAME_DELAY, value);
000706  000910  //       : value = 0 to 65535 ms
000707  000911  //       : Sets the Video/Animation clip inter-frame delay. This setting will
000708  000912  //       : over-ride the embedded frame delay of the clip. After the event,
000709  000913  //       : the setting will auto disable and if further inter-frame delays need
000710  000914  //       : overriding the setting must be re-issued.
000711  000915  //       :
000712  000916  //       : mode = SCREEN_MODE (mode 23) : Set required screen behaviour
000713  000917  //       : gfx_Set(SCREEN_MODE, value);
000714  000918  //       : value = LANDSCAPE   (value 0)
000715  000919  //       : value = LANDSCAPE_R (value 1)
000716  000920  //       : value = PORTRAIT    (value 2)
000717  000921  //       : value = PORTRAIT_R  (value 3)
000718  000922  //       :
000719  000923  //       : mode = OUTLINE_COLOUR (mode 24) : Outline Colour
000720  000924  //       : gfx_Set(OUTLINE_COLOUR, value);
000721  000925  //       : value = 1 to 0xFFFF, if 0, featre is OFF
000722  000926  //       : Sets the filled Rectangle or Circle objects outline colour
000723  000927  //       : If outline colour, is 0, OUTLINE_COLOUR feature is disabled
000724  000928  //       : gfx_Set(OUTLINE_COLOUR, OFF); may be used for this
000725  000929  //       :
000726  000930  //       : Only supports variable contrast for uOLED Modules
000727  000931  //       : mode = CONTRAST (mode 25) : Contrast
000728  000932  //       : gfx_Set(CONTRAST, value);
000729  000933  //       : value = 0 to 9, 0=off, 1=lowest, 8=highest contrast
000730  000934  //       : when contrast=0, display is placed in low power mode.
000731  000935  //       : This function should be called with contrast=0 when
000732  000936  //       : powering down the module.
000733  000937  //       :
000734  000938  //       : mode = LINE_PATTERN (mode 26) : Line Pattern
000735  000939  //       : gfx_Set(LINE_PATTERN, value);
000736  000940  //       : gfx_Set(LINE_PATTERN, 0b1111000011110000); // draw dotted line
000737  000941  //       : gfx_Set(LINE_PATTERN, OFF); // line patterning OFF
000738  000942  //       : a value of 0 turns the feature off
000739  000943  //       :
000740  000944  //       : mode = COLOUR_MODE (mode 27) : 8/16 bit colour mode
000741  000945  //       : gfx_Set(COLOUR_MODE , COLOUR16);   // set 16bit colour mode
000742  000946  //       : gfx_Set(COLOUR_MODE , COLOUR8);   // set 8bit colour mode
000743  000947  //       : NB not implemented, default is COLOUR16
000744  000948  //       :
000745  000949  //       : mode = BEVEL_WIDTH (mode 28) : set button and slider bevel width
000746  000950  //       : gfx_Set(BEVEL_WIDTH , 5);   // set bevel lines to 5 pixels wide
000747  000951  //       : sets the button and slider objects bevel width
000748  000952  //       :
000749  000953  //       : mode = BEVEL_SHADOW (mode 29) : set bevel shadowing depth for buttons and sliders
000750  000954  //       : gfx_Set(BEVEL_SHADOW , 5);
000751  000955  //       : sets the button and slider objects darken and lighten depth for the bevel colour
000752  000956  //       :
000753  000957  //       : mode = X_ORIGIN (mode 29) : set x offset for screen
000754  000958  //       : gfx_Set(X_ORIGIN , 25);  // object are offset 25 pixels from LHS
000755  000959  //       : sets the origin of drawn objects to a position other than 0,0
000756  000960  //       :
000757  000961  //       : mode = Y_ORIGIN (mode 29) : set y offset for screen
000758  000962  //       : gfx_Set(Y_ORIGIN , 30);  // object are offset 30 pixels from TOP
000759  000963  //       : sets the origin of drawn objects to a position other than 0,0
000760  000964        
000761  000965        
000762  000966  func gfx_Cls(), 0;                    // clear the screen
000763  000967  // Syntax: gfx_Cls();
000764  000968  // Usage : gfx_Cls();
000765  000969  // Notes : Clears the screen with current background colour
000766  000970        
000767  000971  func gfx_MoveTo("x", "y"), 0;                // set glb_X1 and glb_Y1 to required co-ordinate
000768  000972  // Syntax: gfx_MoveTo(x, y);
000769  000973  // Usage : gfx_MoveTo(arg1, arg2);
000770  000974  // Notes : Moves the origin to a new x,y position
000771  000975        
000772  000976  func gfx_MoveRel("x", "y"), 0;                // set glb_X1 and glb_Y1 to new relative offset
000773  000977  // Syntax: gfx_MoveRel(x, y);
000774  000978  // Usage : gfx_MoveRel(arg1, arg2);
000775  000979  // Notes : Moves the origin to a new x,y position
000776  000980  //       : relative to the current origing
000777  000981        
000778  000982  func gfx_LineTo("x1", "y1"), 0;                     // draw line from current origin to new point
000779  000983  // Syntax: gfx_LineTo(x1, y1);
000780  000984  // Usage : gfx_LineTo(arg1, arg2);
000781  000985  // Notes : Draws a Line from the origin x,y to x1,y1.
000782  000986  //       : The new origin is then set to x1, y1. Line colour needs
000783  000987  //       : to be preset with "Set Object colour" using gfx_Set(mode=2, colour);
000784  000988        
000785  000989  func gfx_LineRel("x1", "y1"), 0;                    // draw line from current origin to new relative offset
000786  000990  // Syntax: gfx_LineRel(x1, y1);
000787  000991  // Usage : gfx_LineRel(arg1, arg2);
000788  000992  // Notes : Draws a Line from the origin x,y to x1,y1.
000789  000993  //       : Unlike gfx_MoveTo() the origin is not updated with x1, y1. Line colour needs
000790  000994  //       : to be preset with "Set Object colour" using gfx_Set(OBJECT_COLOUR, colour);
000791  000995        
000792  000996  func gfx_Line("x1", "y1", "x2", "y2", "colr"), 0;   // draw line, can be patterned
000793  000997  // Syntax: gfx_Line(x1, x2, y2, colr);
000794  000998  // Usage : gfx_Line(arg1, arg2, arg3, arg4, arg5);
000795  000999  // Notes : Plots a coloured Line from x1,y1 to x2,y2 on the screen
000796  001000        
000797  001001  func gfx_Hline("y", "x1", "x2", "colr"), 1;         // draw Hline, can be patterned
000798  001002  // Syntax: gfx_Line(x1, x2, y, colr);
000799  001003  // Usage : gfx_Line(arg1, arg2, arg3, arg4);
000800  001004  // Notes : Plots a coloured Horizontal line from x1,y to x2,y on the screen
000801  001005        
000802  001006  func gfx_Vline("x", "y1", "y2", "colr"), 1;         // draw Vline, can be patterned
000803  001007  // Syntax: gfx_Line(y1, y2, x, colr);
000804  001008  // Usage : gfx_Line(arg1, arg2, arg3, arg4);
000805  001009  // Notes : Plots a coloured Vertical line from x,y1 to x,y2 on the screen
000806  001010        
000807  001011  func gfx_Rectangle("x1" ,"y1", "x2", "y2", "colr"), 0;    // draw open rectangle,line can be patterned
000808  001012  // Syntax: gfx_Rectangle(x1, y1, x2, y2, colr);
000809  001013  // Usage : gfx_Rectangle(arg1, arg2, arg3, arg4, arg5);
000810  001014  // Notes : Plots a coloured Outline Rectangle from top corner (x1,y1) to
000811  001015  //       : bottom corner (x2,y2) on the screen.
000812  001016        
000813  001017  func gfx_RectangleFilled("x1","y1","x2","y2","colr"), 0;    // draw filled rectangle
000814  001018  // Syntax: gfx_Rectangle(x1, y1, x2, y2, colour);
000815  001019  // Usage : gfx_Rectangle(arg1, arg2, arg3, arg4, arg5);
000816  001020  // Notes : Plots a coloured Solid Rectangle from top corner (x1,y1) to
000817  001021  //       : bottom corner (x2,y2) on the screen.
000818  001022        
000819  001023  func gfx_Circle("x", "y", "rad", "colr"), 0;        // draw open circle
000820  001024  // Syntax: gfx_Circle(x, y, rad, colr);
000821  001025  // Usage : gfx_Circle(arg1, arg2, arg3, arg4);
000822  001026  // Notes : Plots a coloured outline Circle on the screen at centre x,y with radius = rad
000823  001027        
000824  001028  func gfx_CircleFilled("x", "y", "rad", "colr"), 0;    // draw filled circle
000825  001029  // Syntax: gfx_Circle(x, y, rad, colr);
000826  001030  // Usage : gfx_Circle(arg1, arg2, arg3, arg4);
000827  001031  // Notes : Plots a coloured Solid Circle on the screen at centre x,y with radius = rad
000828  001032        
000829  001033  func gfx_PutPixel("x", "y", "colr"), 0;            // set point at x y
000830  001034  // Syntax: gfx_PutPixel(x, y, colr);
000831  001035  // Usage : gfx_PutPixel(arg1, arg2, arg3);
000832  001036  // Notes : Plots a coloured pixel on the screen at x,y location
000833  001037        
000834  001038  func gfx_GetPixel("x", "y"), 1;                // read colour at point x y
000835  001039  // Syntax: gfx_GetPixel(x, y);
000836  001040  // Usage : var := gfx_GetPixel(arg1, arg2);
000837  001041  // Notes : Reads and returns the colour value of a pixel at location x,y
000838  001042        
000839  001043  func gfx_Triangle("x1","y1","x2","y2","x3","y3","colr"), 0; // draw an open triangle
000840  001044  // Syntax: gfx_Triangle(x1, y1, x2, y2, x3, y3, colr);
000841  001045  // Usage : gfx_Triangle(arg1, arg2, arg3, arg4, arg5, arg6, arg7);
000842  001046  // Notes : Plots a coloured outline Triangle from between 3 vertices: x1,y1 x2,y2 x3,y3
000843  001047  //       : Vertices must be specified in an anti-clockwise fashion
000844  001048        
000845  001049  func gfx_OrbitInit("&x_orb", "&y_orb"), 0;        // set result holders for orbit command
000846  001050  // Syntax: gfx_OrbitInit(&x_orb, &y_orb);
000847  001051  // Usage : gfx_OrbitInit(&arg1, &arg2);
000848  001052  // Notes : Sets up the Orbit function parameters.
000849  001053  //       : &x_orb, &y_orb: calcualted Orbit coordiantes. These are pointers to local
000850  001054  //       : variables that get updated after calling gfx_Orbit(,,) function.
000851  001055  //       : The coordiantaes are calculated relative to the origin
000852  001056  //       : obtained by using the gfx_MoveTo(x, y) function.
000853  001057        
000854  001058  func gfx_Orbit("angle", "distance"), 0;            // calculate point at angle, distance
000855  001059  // Syntax: gfx_Orbit(angle, distance);
000856  001060  // Usage : gfx_Orbit(arg1, arg2);
000857  001061  // Notes : The Orbit function calcualtes the x, y coordinates of a distant point whose
000858  001062  //       : only known parameters are the angle and the distance from the current origin.
000859  001063        
000860  001064  func gfx_Polyline("n", "&vx", "&vy", "colr"), 0;    // draw a polyline from a table of vertices
000861  001065  // Syntax: gfx_Polyline(numbVertices, &vertices_x, &vertices_y, colour);
000862  001066  // Usage : gfx_Polyline(arg1, x[array], y[array], arg2);
000863  001067  // Notes : This function is very similar to the Ploygon function
000864  001068  //       : with the exception of the 1st and the last vertices not joined.
000865  001069        
000866  001070  func gfx_Polygon("n", "&vx", "&vy", "colr"), 0;        // draw a polygon from a table of vertices
000867  001071  // Syntax: gfx_Polygon(numbVertices, &vx, &y, colour);
000868  001072  // Usage : gfx_Polygon(arg1, x[array], y[array], arg2);
000869  001073  // Notes : Plots a coloured outline Polygon between specified vertices: x1,y1 x2,y2 .. xn,yn
000870  001074  //       : Vertices must be minimum of 3 and can be specified in any fashion
000871  001075        
000872  001076  func gfx_Dot(), 0;                    // set point at glb_X glb_Y, default colour
000873  001077  // Syntax: gfx_Dot();
000874  001078  // Usage : gfx_Dot();
000875  001079  // Notes : Places a coloured dot at the origin
000876  001080        
000877  001081        
000878  001082  func gfx_Bullet("r"), 0;                // draw circle at glb_X glb_Y, default colour
000879  001083  // Syntax: gfx_Bullet();
000880  001084  // Usage : gfx_Bullet();
000881  001085  // Notes : Places a coloured circle at the origin
000882  001086  //       : filled or unfilled state is controlled by PenSize
000883  001087        
000884  001088  func gfx_IncX(), 1;                    // increment global origin glb_X, returning new value
000885  001089  // Syntax: gfx_IncX();
000886  001090  // Usage : var := gfx_IncX();
000887  001091  // Notes : Increments the x coordinate of the origin
000888  001092        
000889  001093  func gfx_IncY(), 1;                    // increment global origin glb_Y, returning new value
000890  001094  // Syntax: gfx_IncY();
000891  001095  // Usage : var := gfx_IncY();
000892  001096  // Notes : Increments the y coordinate of the origin
000893  001097        
000894  001098  func gfx_BoxTo("x1", "y1"), 0;                // draw rectangle from current origin to x1 y1
000895  001099  // Syntax: gfx_BoxTo(x1, y1);
000896  001100  // Usage : gfx_BoxTo(arg1, arg2);
000897  001101  // Notes : Draws a Rectangle from the origin x,y to x1,y1.
000898  001102  //       : The new origin is then set to x1,y1. Rectangle colour needs
000899  001103  //       : to be preset with "Set Object colour" using gfx_Set(mode=2, colour);
000900  001104  //       : and the PenSize setting determines if Box is solid or outline.
000901  001105        
000902  001106  func gfx_ClipWindow("x1" ,"y1", "x2", "y2"), 0;         // set the cipping area
000903  001107  // Syntax: gfx_ClipWindow(x1, y1, x2, y2);
000904  001108  // Usage : gfx_ClipWindow(arg1, arg2, arg3, arg4);
000905  001109  // Notes : Specifies a clipping window region on the screen such that any objects
000906  001110  //       : and text placed onto the screen will be clipped and displayed only
000907  001111  //       : within that region. For the clipping window to take effect, "Clipping"
000908  001112  //       : must be enabled seperately using the gfx_Set(CLIPPING, ON) command.
000909  001113        
000910  001114        
000911  001115  func gfx_ChangeColour("oldcolr", "newcolr"), 0;         // change pixel colour in clipping area
000912  001116  // Syntax: gfx_ChangeColour(oldcolr, newcolr);
000913  001117  // Usage : gfx_ChangeColour(0xFF00, 0XFFFF);
000914  001118  // *Notes:
000915  001119        
000916  001120  func gfx_SetClipRegion(), 0;                            // set clipping area to the most recent extents
000917  001121  // Syntax: gfx_SetClipRegion();
000918  001122  // Usage : var := gfx_SetClipRegion();
000919  001123  // *Notes:
000920  001124        
000921  001125  func gfx_Ellipse("x", "y", "xrad", "yrad", "colour"), 0;
000922  001126  // Syntax: gfx_Ellipse(x, y, xrad, yrad, colour);
000923  001127  // Usage : gfx_Ellipse(arg1, arg2, arg3, arg4, arg5);
000924  001128  // Notes : Plots a coloured Ellipse on the screen at centre x,y
000925  001129  //       : with xradius = xrad and yradius = yrad.
000926  001130  //       : if PenSize = 0 Ellipse is Solid
000927  001131  //       : if PenSize = 1 Ellipse is Outline
000928  001132        
000929  001133        
000930  001134  func gfx_EllipseFilled("x", "y", "xrad", "yrad", "colour"), 0;
000931  001135  // Syntax: gfx_EllipseFilled(x, y, xrad, yrad, colour);
000932  001136  // Usage : gfx_EllipseFilled(arg1, arg2, arg3, arg4, arg5);
000933  001137  // Notes : Plots a coloured Ellipse on the screen at centre x,y
000934  001138  //       : with xradius = xrad and yradius = yrad.
000935  001139        
000936  001140  func gfx_Button("state", "x", "y", "buttonColour", "textColour", "font", "textWidth", "textHeight", "text"), 0;
000937  001141  // Syntax: gfx_Button(mode, x, y, buttonColour, textColour, font, textWidth, textHeight, text);
000938  001142  // Usage : gfx_Button(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9);
000939  001143  // Notes : Draws a 3 dimensional Text Button at screen location defined by
000940  001144  //       : x,y arguments (top left corner). The size of the button depends on
000941  001145  //       : the font, width, height and length of the text.
000942  001146  //       : The button appearance will depend on the state parameter setting:
000943  001147  //       :         state = 0 : Button Pressed
000944  001148  //       :         state = 1 : Button Raised
000945  001149        
000946  001150  func gfx_Panel("state", "x", "y", "width", "height", "colour"), 0;
000947  001151  // Syntax: gfx_Panel("style", "x", "y", "width", "height", "colour"), 0;
000948  001152  // Usage : gfx_Panel(PANEL_RAISED, x, y, w, h, GRAY);
000949  001153  // Notes : Draws a panel (groupbox) at screen location defined by
000950  001154  //       : x, y, width and height with colour "colour".
000951  001155  //       :         state = 0 : recessed
000952  001156  //       :         state = 1 : raised
000953  001157        
000954  001158  func gfx_Slider("mode", "x1", "y1", "x2", "y2", "colour", "scale", "value"), 1;
000955  001159  // Syntax: gfx_Slider(mode, x1, y1, x2, y2, colour, scale, value);
000956  001160  // Usage : gfx_Slider(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8);
000957  001161  // Notes : Draws a 3 dimensional Slider Bar on the screen.
000958  001162  //       : Slider parameters are as follows:
000959  001163  //       :         mode = 0 : Slider recessed
000960  001164  //       :         mode = 1 : Slider raised
000961  001165  //       :         x1, y1 = top left corner
000962  001166  //       :         x2, y2 = bottom right corner
000963  001167  //       :         scale = n : sets the full scale range from 0 to n
000964  001168  //       :         value = m : sets the relative position of the thumb 0 <= m <= n
000965  001169  //       : returns:-
000966  001170        
000967  001171        
000968  001172  func gfx_ScreenCopyPaste("xs", "ys", "xd", "yd", "width", "height"), 0;
000969  001173  // Syntax: gfx_ScreenCopyPaste(xs, ys, xd, yd, width, height);
000970  001174  // Usage : gfx_ScreenCopyPaste(arg1, arg2, arg3, arg4, arg5, arg6);
000971  001175  // Notes : Copies an area of a screen from xs,ys of size given by width and height
000972  001176  //       : and pastes it to another location determined by xd, yd.
000973  001177        
000974  001178  func gfx_RGBto565("RED", "GREEN", "BLUE"), 1;
000975  001179  // Syntax: gfx_RGBto565(red, green, blue);
000976  001180  // Usage : gfx_RGBto565(arg1, arg2, arg3);
000977  001181  // Notes : Returns the 16bit (565 format) colour value of a 24bit (R,G,B format) colour
000978  001182        
000979  001183  func gfx_332to565("COLOUR8BIT"), 1;
000980  001184  // Syntax: gfx_332to565(colour);
000981  001185  // Usage : gfx_332to565(arg);
000982  001186  // Notes : Returns the 16bit (565 format) colour value of an 8 bit (332 format) colour
000983  001187        
000984  001188  func gfx_Selection("index", "backcolor", "textcolor"), 0;
000985  001189  // Syntax: gfx_Selection("index", "backcolor", "textcolor"), 0;
000986  001190  // Usage : gfx_Selection(1, RED, YELLOW);
000987  001191  // Notes : Called prior to drawing a button, this function
000988  001192  //       : hilites the required text line on a multiline button.
000989  001193        
000990  001194  func gfx_TriangleFilled("x1","y1","x2","y2","x3","y3","colr"), 0; // draw a filled triangle
000991  001195  // Syntax: gfx_TriangleFilled(x1, y1, x2, y2, x3, y3, colr);
000992  001196  // Usage : gfx_TriangleFilled(arg1, arg2, arg3, arg4, arg5, arg6, arg7);
000993  001197  // Notes : Plots a coloured Solid Triangle from between 3 vertices: x1,y1 x2,y2 x3,y3
000994  001198  //       : Vertices must be specified in an anti-clockwise fashion
000995  001199        
000996  001200        
000997  001201  func gfx_PolygonFilled("n", "&vx", "&vy", "colr"), 0;        // draw a filled polygon from a table of vertices
000998  001202  // Syntax: gfx_PolygonFilled(numbVertices, &vx, &y, colour);
000999  001203  // Usage : gfx_PolygonFilled(arg1, x[array], y[array], arg2);
001000  001204  // Notes : Plots a solid Polygon between specified vertices: x1,y1 x2,y2 .. xn,yn
001001  001205  //       : Vertices must be minimum of 3 and can be specified in any fashion
001002  001206        
001003  001207        
001004  001208  func gfx_Origin("x", "y"), 0;            // set relative screen offset for graphics objects
001005  001209  // Syntax: gfx_Offset(x, y);
001006  001210  // Usage : gfx_Offset(arg1, arg2);
001007  001211  // Notes : Set the screen offset
001008  001212        
001009  001213        
001010  001214        
001011  001215  func gfx_Get("mode"), 1;
001012  001216  // Syntax: gfx_Get(mode);
001013  001217  // Usage : arg1 := gfx_Get(arg);
001014  001218  // Notes : Returns various parameters to caller
001015  001219  //       :
001016  001220  //       : mode = X_MAX (mode 0) : current orientations maximum X value
001017  001221  //       : var := gfx_Get(X_MAX);
001018  001222  //       : Returns the maximum horizontal value of the display
001019  001223  //       :
001020  001224  //       : mode = Y_MAX (mode 1) : Vcurrent orientations maximum Y value
001021  001225  //       : var := gfx_Get(Y_MAX);
001022  001226  //       : Returns the maximum vertical value of the display
001023  001227  //       :
001024  001228  //       : mode = LEFT_POS (mode 2) : Left location of last Object
001025  001229  //       : var := gfx_Get(LEFT_POS);
001026  001230  //       : Returns the left location of the last drawn object
001027  001231  //       : such as a slider or button or an image/video
001028  001232  //       :
001029  001233  //       : mode = TOP_POS (mode 3) : Top location of Object
001030  001234  //       : var := gfx_Get(TOP_POS);
001031  001235  //       : Returns the top location of the last drawn object
001032  001236  //       : such as a slider or button or an image/video
001033  001237  //       :
001034  001238  //       : mode = RIGHT_POS (mode 4) : Right location of last Object
001035  001239  //       : var := gfx_Get(RIGHT_POS);
001036  001240  //       : Returns the right location of the last drawn object
001037  001241  //       : such as a slider or button or an image/video
001038  001242  //       :
001039  001243  //       : mode = BOTTOM_POS  (mode 5) : Bottom location of Object
001040  001244  //       : var := gfx_Get(BOTTOM_POS );
001041  001245  //       : Returns the bottom location of the last drawn object
001042  001246  //       : such as a slider or button or an image/video
001043  001247  //       :
001044  001248        
001045  001249        
001046  001250  //==================================================//
001047  001251  // Single parameter short-cuts                      //
001048  001252  // for the gfx_Set functions                        //
001049  001253  // These functions return the existing value before //
001050  001254  // the change is made.                              //
001051  001255  //==================================================//
001052  001256  func gfx_PenSize("mode"), 1;                        // 0  graphics pen size, SOLD or OUTLINE
001053  001257  func gfx_BGcolour("colour"), 1;                     // 1  graphics background colour
001054  001258  func gfx_ObjectColour("colour"), 1;                 // 2  graphics object colour
001055  001259  func gfx_Clipping("mode"), 0;                       // 3  graphics clipping ON/OFF
001056  001260  func gfx_TransparentColour("colour"), 1;            // 4  graphics image transparent mask colour
001057  001261  func gfx_Transparency("mode"), 1;                   // 5  graphics image transparent mode ON/OFF
001058  001262  func gfx_FrameDelay("milliseconds"), 1;             // 6  graphics animation frame delay
001059  001263  func gfx_ScreenMode("mode"), 1;                     // 7  graphics orientation LANDSCAPE, LANDSCAPE_R, PORTRAIT, PORTRAIT_R
001060  001264  func gfx_OutlineColour("colour"), 1;                // 8  graphics rectangle/circle outline colour
001061  001265  func gfx_Contrast("value"), 1;                      // 9  graphics hardware value 0 to 9, 0=off, 1=lowest, 8=highest (only for AMOLED devices)
001062  001266  func gfx_LinePattern("value"), 1;                   // 10 graphics line draw tesselation pattern (16 linear bits, 1=pixel off)
001063  001267  func gfx_ColourMode("mode"), 1;                     // 11 graphics colour mode COLOUR8 or COLOUR16 (default colour 16)
001064  001268  func gfx_BevelWidth("mode"), 1;                     // 12 graphics button bevel width
001065  001269  func gfx_BevelShadow("value"), 1;                   // 13 graphics button bevel shadow depth
001066  001270  func gfx_Xorigin("offset"), 1;                      // 14 graphics  X origin
001067  001271  func gfx_Yorigin("offset"), 1;                      // 15 graphics  Y origin
001068  001272        
001069  001273        
001070  001274  //==================================================//
001071  001275  // uSD/FLASH Function Prototypes                    //
001072  001276  //==================================================//
001073  001277  func media_Video("x", "y"), 0;                      // display movie at position x y
001074  001278  // Syntax: media_Video(x, y);
001075  001279  // Usage : media_Video(arg1, arg2);
001076  001280  // Notes : Play a Video/Animation clip from the uSD card at screen location
001077  001281  //       : specified by x,y (top left corner). The location of the clip in the
001078  001282  //       : uSD card must be specified by media_setSector(Video_Sector_Add) function.
001079  001283        
001080  001284  func media_VideoFrame("x", "y","framenumber"), 0;   // display required frame from a movie at x y
001081  001285  // Syntax: media_VideoFrame(Frame_number);
001082  001286  // Usage : arg1 := media_VideoFrame();
001083  001287  // Notes : After a pointer to a valid video has been set with media_SetSector,
001084  001288  //       : calling this function shows each fram sequentially, returning
001085  001289  //       : the number of frames remaining. The position of the image is
001086  001290  //     : at the current origin as set with gfx_MoveTo(...);
001087  001291        
001088  001292  func media_SetAdd("HiWord", "LoWord"), 0;           // set stream byte address
001089  001293  // Syntax: media_SetAdd(AddHiWord, AddLoWord);
001090  001294  // Usage : media_SetAdd(arg1, arg2);
001091  001295  // Notes : Set uSD internal Address pointer for bytewise access
001092  001296        
001093  001297  func media_SetSector("HiWord", "LoWord"), 0;        // set stream sector address
001094  001298  // Syntax: media_SetSector(SectHiWord, SectLoWord);
001095  001299  // Usage : media_SetSector(arg1, arg2);
001096  001300  // Notes : Set uSD internal Sector pointer for sector block access
001097  001301        
001098  001302  func media_RdSector("*destination"), 1;
001099  001303  // Syntax: media_RdSector(*destination);
001100  001304  // Usage : media_RdSector(rdblock);
001101  001305  // Notes : Reads and Returns 512 bytes (256 words) into a destination
001102  001306  //       : block (eg rdblock[256]) pointed to by the internal Sector pointer.
001103  001307  //       : After the read the Sector pointer is automatically incremented by 1.
001104  001308  //       : Returns TRUE if uSD response was TRUE
001105  001309        
001106  001310  func media_WrSector("*source"), 1;
001107  001311  // Syntax: media_WrSector(*source);
001108  001312  // Usage : media_WrSector(wrblock);
001109  001313  // Notes : Writes 512 bytes (256 words) from a source memory block
001110  001314  //       : (eg wrblock[256]) into the uSD card. After the write the Sector
001111  001315  //       : pointer is automatically incremented by 1.
001112  001316  //       : Returns TRUE if uSD response was TRUE
001113  001317        
001114  001318  func media_ReadByte(), 1;                // read a byte at the current stream position
001115  001319  // Syntax: media_RdByte();
001116  001320  // Usage : var := media_RdByte();
001117  001321  // Notes : Reads and Returns a single byte of data from the
001118  001322  //       : uSD card pointed to by the internal Address pointer.
001119  001323  //       : After the read the Address pointer is automatically
001120  001324  //       : incremented by 1.
001121  001325        
001122  001326  func media_ReadWord(), 1;                // read a word at the current stream position
001123  001327  // Syntax: media_ReadWord();
001124  001328  // Usage : var := media_ReadWord();
001125  001329  // *Notes : Reads and Returns a single word of data from the
001126  001330  //       : uSD card pointed to by the internal Address pointer.
001127  001331  //       : After the read the Address pointer is automatically
001128  001332  //       : incremented by 2.
001129  001333        
001130  001334  func media_WriteByte("byte"), 1;              // write a byte to the current stream position
001131  001335  // Syntax: media_WriteByte(arg1);
001132  001336  // Usage : var := media_WriteByte(arg1);
001133  001337  // *Notes : Writes and Returns xxxxx
001134  001338  //       : After the write the Address pointer is automatically
001135  001339  //       : incremented by 1.
001136  001340        
001137  001341  func media_WriteWord("word"), 1;            // write a word to the current stream position
001138  001342  // Syntax: media_WriteWord(arg1);
001139  001343  // Usage : var := media_WriteWord(arg1);
001140  001344  // *Notes : Writes and Returns xxxxx
001141  001345  //       : After the write the Address pointer is automatically
001142  001346  //       : incremented by 2.
001143  001347        
001144  001348  func media_Image("x", "y"), 0;            // display image at position x y
001145  001349  // Syntax: media_Image(x, y);
001146  001350  // Usage : media_Image(arg1, arg2);
001147  001351  // Notes : Display an image from the uSD card at screen location
001148  001352  //       : specified by x,y (top left corner). The location of the
001149  001353  //       : Image in the uSD card must be specified by
001150  001354  //       : media_setSector(Image_Sector_Add) function.
001151  001355        
001152  001356  func media_Flush(), 1;                    // after writing to media, flush the sector and write
001153  001357  // Syntax: media_Flush();
001154  001358  // Usage : var := media_Flush();
001155  001359  // *Notes : After writing any data to a sector, media_Flush() should be called to ensure that the current sector that
001156  001360  //       : is being written is correctly stored back to the media else write operations may be unpredictable.
001157  001361        
001158  001362  func media_Init(), 1;                    // initialize uSD card
001159  001363  // Usage : media_Init();
001160  001364  // Notes : Initialise uSD CARD
001161  001365  //       : Response: 0 = No Card
001162  001366  //       :           1 = Card Initialised
001163  001367        
001164  001368        
001165  001369  //==============================================//
001166  001370  // Communications Function Prototypes           //
001167  001371  //==============================================//
001168  001372  func com_Init("buf","bufsize","qualifier"), 0;  // set up a interrupt driven ring buffer for comms
001169  001373  // Syntax: com_Init(buffer, bufsize, qualifier);
001170  001374  // Usage1: com_Init(mybuf, 20, 0);
001171  001375  // Usage2: com_Init(mybuf, 20, ':');
001172  001376  // Notes : initialize a serial capture buffer for the comms input
001173  001377  //       : The program must declare a var array as a circular buffer.
001174  001378  //       : Usage1 declares a circular buffer which will continually
001175  001379  //       : buffer characters.
001176  001380  //       : Usage2 must receive ':' before any characters will
001177  001381  //       : accumulate in the buffer.
001178  001382        
001179  001383  func com_Reset(), 0;                 // reset the comms receiver
001180  001384  // Syntax: com_Reset();
001181  001385  // Usage : com_Reset();
001182  001386  // Notes : reset comms to default polled mode
001183  001387        
001184  001388  func com_Count(), 1;                // return count of characters in receive buffer
001185  001389  // Syntax: com_Count();
001186  001390  // Usage : arg := com_Count();
001187  001391  // Notes : return count of buffered characters in buffer attachment
001188  001392        
001189  001393  func com_Full(), 1;                // return TRUE if receiver buffer filled to capcity
001190  001394  // Syntax: com_Full();
001191  001395  // Usage : if (com_Full() ,,,, go read buffer;
001192  001396  // Notes : return true if buffer full (not necessarily an error if
001193  001397  //       : buffer is sized to a packet size)
001194  001398        
001195  001399  func com_Error(), 1;                // return comms errors comms error occurred
001196  001400  // Syntax: com_Error();
001197  001401  // Usage : if (com_Error() ) ...... take recovery action;
001198  001402  // Notes : return non zero if any errors low level comms errors occured
001199  001403  // returns :
001200  001404  // bit0 = Receiver Overflow Error
001201  001405  // bit1 = Receiver Framing Error
001202  001406  // bit2 = Transmit Buffer Overflow
001203  001407        
001204  001408  func com_Sync(), 1;                // returns TRUE if qualifier has been received
001205  001409  // Syntax: com_Sync();
001206  001410  // Usage : com_Sync();
001207  001411  // return true if sync character has been received in com_Init("...") mode
001208  001412        
001209  001413        
001210  001414  func com_TXbuffer("buf", "bufsize", "pin"), 0;    // sets the buffer location for buffered transmission
001211  001415  // Syntax: com_TXbuffer("buf", "bufsize", "pin");
001212  001416  // Usage : com_TXbuffer(mybuf, 1024, IO1_PIN);    // set the TX buffer, usin IO1_PIN for turnaround
001213  001417  // Usage : com_TXbuffer(0, 0, 0);              // revert to non buffered service
001214  001418  // Notes : initialize a serial buffer for the COM0 output.
001215  001419  //       : The program must declare a var array as a circular buffer.
001216  001420  //       : When a TX buffer is declared for comms, the transmission
001217  001421  //       : of characters becomes non blocking. The only time
001218  001422  //       : blocking will occur is if the buffer has insufficient space
001219  001423  //       : to accept the next character, in which case the function
001220  001424  //       : will wait for buffer space to become available. If the
001221  001425  //       : TX buffer is no longer required, just set the buffer pointer
001222  001426  //       : to zero, the size in this case doesnt matter and is ignored.
001223  001427  //       : The function can resize or reallocated to another buffer at
001224  001428  //       : any time. The buffer is flushed before any changes are made.
001225  001429  //       : "pin" designates an IO pin to control a bi-directional 
001226  001430  //       : control device for half duplex mode. "pin" will go HI at the
001227  001431  //       : start of a transmission, and will return low after the final
001228  001432  //       : byte is transmitted. If not required, just set "pin" to zero.
001229  001433        
001230  001434        
001231  001435  func com_TXcount(), 1;                // return count of characters in COM0 TX buffer
001232  001436  // Syntax: com_TXcount();
001233  001437  // Usage : arg := com_Count();
001234  001438  // Notes : return count of characters remaining in COM0 transmit buffer
001235  001439  //       : that was previously allocated with com_TXbuffer(...);
001236  001440        
001237  001441        
001238  001442  func com_TXemptyEvent("function"), 1;  // sets a function to be called when COM0 TX buffer empty
001239  001443  // Syntax: com_TXemptyEvent(function);
001240  001444  // Usage : arg := com_TXemptyEvent();
001241  001445  // Notes : If a comms TX buffer that was previously allocated with
001242  001446  //       : com_TXbuffer(...);, this function can be used to set up
001243  001447  //       : a function to be called when the COM0 TX buffer is empty.
001244  001448  //       : This is useful for either reloading the TX buffer, setting
001245  001449  //       : or clearing a pin to change the direction of eg a RS485
001246  001450  //       : line driver, or any other form of traffic control.
001247  001451  //       : The event function must not have any parameters.
001248  001452  //       : To disable the event, simply call com_TXemptyEvent(0).
001249  001453  //       : com_TXbuffer(...); also resets any active event.
001250  001454  //       : com_TXemptyEvent returns any previous event function
001251  001455  //       : address, or zero if there was no previous function.
001252  001456        
001253  001457        
001254  001458  func com_TXbufferHold("state"), 1; // hold or release a com_TXbuffer
001255  001459  // Usage : arg := com_TXbufferHold(ON);  // hold the buffer while we fill it
001256  001460  // Usage : arg := com_TXbufferHold(OFF);  // start sending the buffer
001257  001461  // Notes : Expecting that a comms TX buffer that was previously allocated with
001258  001462  //       : com_TXbuffer(...);, com_TXbufferHold(ON) can be used to stop
001259  001463  //       : the buffer being sent wile it is being loaded. Mormally, when
001260  001464  //       : using buffered comms, the transmit process will begin
001261  001465  //       : immediately. This is often undesirable for 2 reasons,
001262  001466  //       : 1] you may wish to build a packet then send it later
001263  001467  //       : 2] when using com_TXemptyEvent erroneous empty events will occur
001264  001468  //       : as the FIFO buffer is constantly trying to empty while
001265  001469  //       : you are busy tring to fill it.
001266  001470  // return -1 if function is called illegally when TX comms is not buffered.
001267  001471  // return buffer count when called with argument of 1, eg com_TXbufferHold(ON)
001268  001472  // return 0 when argument is zero, eg com_TXbufferHold(OFF)
001269  001473        
001270  001474        
001271  001475  //=============================================================//
001272  001476  // Auxilliary Communications Function Prototypes
001273  001477  //=============================================================//
001274  001478  func com1_Init("buffer", "bufsize", "qualifier"), 0;
001275  001479  // Syntax: com_Init(buffer, bufsize, qualifier);
001276  001480  // Usage1: com_Init(mybuf, 20, 0);
001277  001481  // Usage2: com_Init(mybuf, 20, ':');
001278  001482  // Notes : initialize a serial capture buffer for the comms input
001279  001483  //       : The program must declare a var array as a circular buffer.
001280  001484  //       : Usage1 declares a circular buffer which will continually
001281  001485  //       : buffer characters.
001282  001486  //       : Usage2 must receive ':' before any characters will
001283  001487  //       : accumulate in the buffer.
001284  001488        
001285  001489  func com1_Reset(), 0;
001286  001490  // Syntax: com_Reset();
001287  001491  // Usage : com_Reset();
001288  001492  // Notes : reset comms receiver to default polled mode
001289  001493        
001290  001494  func com1_Count(), 1;
001291  001495  // Syntax: com_Count();
001292  001496  // Usage : arg := com_Count();
001293  001497  // Notes : return count of characters in receive buffer
001294  001498        
001295  001499  func com1_Full(), 1;
001296  001500  // Syntax: com_Full();
001297  001501  // Usage : if (com_Full() ,,,, go read buffer;
001298  001502  // Notes : return true if receive buffer full
001299  001503        
001300  001504  func com1_Error(), 1;
001301  001505  // Syntax: com_Error();
001302  001506  // Usage : if (com_Error() ) ...... take recovery action;
001303  001507  // Notes : return non zero if any level comms errors occured
001304  001508  // returns :
001305  001509  // bit0 = Receiver Overflow Error
001306  001510  // bit1 = Receiver Framing Error
001307  001511  // bit2 = Transmit Buffer Overflow
001308  001512        
001309  001513  func com1_Sync(), 1;
001310  001514  // Syntax: com_Sync();
001311  001515  // Usage : com_Sync();
001312  001516  // Notes : return true if sync character has been received in com_Init("...") mode
001313  001517        
001314  001518        
001315  001519  func com1_TXbuffer("buf", "bufsize", "pin"), 0;    // sets the buffer location for buffered transmission
001316  001520  // Syntax: com1_TXbuffer("buf", "bufsize", "pin");
001317  001521  // Usage : com1_TXbuffer(mybuf, 1024, IO1_PIN);    // set the TX buffer, usin IO1_PIN for turnaround
001318  001522  // Usage : com1_TXbuffer(0, 0, 0);              // revert to non buffered service
001319  001523  // Notes : initialize a serial buffer for the COM1 output.
001320  001524  //       : The program must declare a var array as a circular buffer.
001321  001525  //       : When a TX buffer is declared for comms, the transmission
001322  001526  //       : of characters becomes non blocking. The only time
001323  001527  //       : blocking will occur is if the buffer has insufficient space
001324  001528  //       : to accept the next character, in which case the function
001325  001529  //       : will wait for buffer space to become available. If the
001326  001530  //       : TX buffer is no longer required, just set the buffer pointer
001327  001531  //       : to zero, the size in this case doesnt matter and is ignored.
001328  001532  //       : The function can resize or reallocated to another buffer at
001329  001533  //       : any time. The buffer is flushed before any changes are made.
001330  001534  //       : "pin" designates an IO pin to control a bi-directional 
001331  001535  //       : control device for half duplex mode. "pin" will go HI at the
001332  001536  //       : start of a transmission, and will return low after the final
001333  001537  //       : byte is transmitted. If not required, just set "pin" to zero.
001334  001538        
001335  001539        
001336  001540  func com1_TXcount(), 1;                // return count of characters in COM1 TX buffer
001337  001541  // Syntax: com1_TXcount();
001338  001542  // Usage : arg := com1_Count();
001339  001543  // Notes : return count of characters remaining in COM1 transmit buffer
001340  001544  //       : that was previously allocated with com1_TXbuffer(...);
001341  001545        
001342  001546        
001343  001547  func com1_TXemptyEvent("function"), 1;  // sets a function to be called when COM1 TX buffer empty
001344  001548  // Syntax: com1_TXemptyEvent(function);
001345  001549  // Usage : arg := com1_TXemptyEvent();
001346  001550  // Notes : If a comms TX buffer that was previously allocated with
001347  001551  //       : com1_TXbuffer(...);, this function can be used to set up
001348  001552  //       : a function to be called when the COM1 TX buffer is empty.
001349  001553  //       : This is useful for either reloading the TX buffer, setting
001350  001554  //       : or clearing a pin to change the direction of eg a RS485
001351  001555  //       : line driver, or any other form of traffic control.
001352  001556  //       : The event function must not have any parameters.
001353  001557  //       : To disable the event, simply call com1_TXemptyEvent(0).
001354  001558  //       : com1_TXbuffer(...); also resets any active event.
001355  001559  //       : com1_TXemptyEvent returns any previous event function
001356  001560  //       : address, or zero if there was no previous function.
001357  001561        
001358  001562        
001359  001563  func com1_TXbufferHold("state"), 1; // hold or release a com1_TXbuffer
001360  001564  // Usage : arg := com1_TXbufferHold(ON);  // hold the buffer while we fill it
001361  001565  // Usage : arg := com1_TXbufferHold(OFF);  // start sending the buffer
001362  001566  // Notes : Expecting that a comms TX buffer that was previously allocated with
001363  001567  //       : com1_TXbuffer(...);, com1_TXbufferHold(ON) can be used to stop
001364  001568  //       : the buffer being sent wile it is being loaded. Mormally, when
001365  001569  //       : using buffered comms, the transmit process will begin
001366  001570  //       : immediately. This is often undesirable for 2 reasons,
001367  001571  //       : 1] you may wish to build a packet then send it later
001368  001572  //       : 2] when using com_TXemptyEvent erroneous empty events will occur
001369  001573  //       : as the FIFO buffer is constantly trying to empty while
001370  001574  //       : you are busy tring to fill it.
001371  001575  // return -1 if function is called illegally when TX comms is not buffered.
001372  001576  // return buffer count when called with argument of 1, eg com1_TXbufferHold(ON)
001373  001577  // return 0 when argument is zero, eg com1_TXbufferHold(OFF)
001374  001578        
001375  001579  func serin1(), 1;
001376  001580  // Syntax: serin1();
001377  001581  // Usage : char := serin1();
001378  001582  // Notes : return the next available character from COM1
001379  001583        
001380  001584  func serout1("char"), 0;
001381  001585  // Syntax: serout1("char");
001382  001586  // Usage : serout1(ch);
001383  001587  // Notes : send character to COM1
001384  001588        
001385  001589  func com_SetBaud("comport","baudrate/10"), 1;
001386  001590  // Syntax: com_SetBaud("comport","baudrate/10");
001387  001591  // Usage : com_SetBaud(COM1, 960);   // set COM1 to 9600 baud
001388  001592  // Notes : sets to any viable baud rate from 160 to 655350
001389  001593  // return true if baud rate was acceptable
001390  001594        
001391  001595        
001392  001596        
001393  001597  //==============================================//
001394  001598  // Display Access                               //
001395  001599  //==============================================//
001396  001600  func disp_Init(), 0;                            // initialize display with required tables
001397  001601        
001398  001602  func disp_SetReg("register", "data"), 0;
001399  001603  // Syntax: display_SetReg(register, data);
001400  001604  // Usage : display_SetReg(arg1, arg2);
001401  001605  // Notes : Sets uLCD specific display driver registers. Refer
001402  001606  //       : to appropriate display driver data sheet.
001403  001607        
001404  001608  func disp_setGRAM("x1","y1","x2","y2"), 0;    // set GRAM window
001405  001609  // Syntax: disp_setGRAM(x1, y1, x2, y2);
001406  001610  // Usage : disp_setGRAM(arg1, arg2, arg3, arg4);
001407  001611  // Notes : Prepares the GRAM area for user access.
001408  001612  //       : Data can now be written with disp_GRAM.
001409  001613  //       : GRAM will be set accordingly for the correct screen mode.
001410  001614  //       : the LO word of the 32 bit pixel count is returned. This is
001411  001615  //       : usually all that is needed unlse GRAM area exceeds 256^2
001412  001616  //       : A copy of the 32bit value can be found in
001413  001617  //       : GRAM_PIXEL_COUNT_LO and GRAM_PIXEL_COUNT_HI
001414  001618        
001415  001619  func disp_WrGRAM("colour"), 0;
001416  001620  // Syntax: display_WrGRAM(colour);
001417  001621  // Usage : display_WrGRAM(arg);
001418  001622  // Notes : Data can be written to the GRAM consecutively using
001419  001623  //       : this function once the GRAM access window has been setup.
001420  001624        
001421  001625  func disp_WriteControl("value"), 0;             // write a control byte to the display
001422  001626  func disp_WriteWord("value"), 0;                // write a word to the display
001423  001627        
001424  001628        
001425  001629  func disp_ReadWord(), 1;                        // read a word from the display
001426  001630  // Syntax: disp_ReadWord();
001427  001631  // Usage : x:=disp_ReadWord();
001428  001632  // Notes : Read a word from the controller
001429  001633  // Eg:   : disp_WriteControl(0);         // select Ilitek ID register
001430  001634  //       : print(disp_ReadWord());        // print ID
001431  001635  //       : (Many displays are write only)
001432  001636        
001433  001637                                                  //
001434  001638  //==============================================//
001435  001639  // unadorned SPI functions                      //
001436  001640  //==============================================//
001437  001641  func spi_Init("speed","ip_mode","op_mode"), 0;  // set the SPI port, not used if uSD active
001438  001642  func spi_Read(), 1;                             // read a raw byte from SPI (lowers CS)
001439  001643  func spi_Write("byte"), 0;                      // write a raw byte to SPI (lowers CS)
001440  001644  func spi_Disable(), 0;                          // disable SPI reading or writing (raise CS)
001441  001645                                                  //
001442  001646  //==============================================//
001443  001647  // flash device specific functions              //
001444  001648  //==============================================//
001445  001649  func flash_SIG(), 1;                            // read Jedecsignature from SPI Flash device
001446  001650  func flash_ID(), 1;                             // read ID code from FLASH device
001447  001651  func flash_BulkErase(), 0;                      // erase the entire FLASH device
001448  001652  func flash_BlockErase("block"), 1;              // erase the required 64k flash block
001449  001653                                                  //
001450  001654                                                  //
001451  001655  //==============================================//
001452  001656  // string and character size function           //
001453  001657  //==============================================//
001454  001658  func charwidth("char"), 1;                      // return width of a character in pixel units
001455  001659  func charheight("char"), 1;                     // return height of a character in pixel units
001456  001660  func strwidth("pointer"), 1;                    // return width of a string in pixel units
001457  001661  func strheight(), 1;                            // return height of a string in pixel units
001458  001662        
001459  001663        
001460  001664  //------------------------------------------------------------------//
001461  001665  //        I2C Function Prototypes
001462  001666  //------------------------------------------------------------------//
001463  001667  func I2C_Open("speed"), 0;
001464  001668  // Syntax: I2C_Open(speed),
001465  001669  // Usage : I2C_Open(I2C_MED);
001466  001670  // Notes : configures the I2C module
001467  001671  //       : speed can be I2C_SLOW, I2C_MED, I2C_FAST (100khz, 400khz, 1mhz)
001468  001672        
001469  001673  func I2C_Close(), 0;
001470  001674  // Syntax: I2C_Close();
001471  001675  // Usage : I2C_Close();
001472  001676  // Notes : disables the I2C1 module.
001473  001677        
001474  001678  func I2C_Start(), 1;
001475  001679  // Syntax: I2C_Start();
001476  001680  // Usage : I2C_Start();
001477  001681  // Notes : generates a Start condition.
001478  001682  //       : returns true if successful (usually ignored)
001479  001683        
001480  001684  func I2C_Stop(), 1;
001481  001685  // Syntax: I2C_Stop();
001482  001686  // Usage : I2C_Stop();
001483  001687  // Notes : generates a Stop condition.
001484  001688  //       : returns true if successful (usually ignored)
001485  001689        
001486  001690  func I2C_Restart(), 1;
001487  001691  // Syntax: I2C_Restart();
001488  001692  // Usage : I2C_Restart();
001489  001693  // Notes : generates a Restart condition.
001490  001694  //       : returns true if successful (usually ignored)
001491  001695        
001492  001696  func I2C_Read(), 1;
001493  001697  // Syntax: I2C_Read();
001494  001698  // Usage : ch := I2C_Read();
001495  001699  // Notes : reads a single byte from the I2C Bus.
001496  001700        
001497  001701  func I2C_Write("byte"), 1;
001498  001702  // Syntax: I2C_Write(byte);
001499  001703  // Usage : r := I2C_Write(ch);
001500  001704  // Notes : is used to write a byte to the I2C bus.
001501  001705  //       : Returns 0 if failed, 1 if no ack, 2 if ack
001502  001706        
001503  001707  func I2C_Ack(), 0;
001504  001708  // Syntax: I2C_Ack();
001505  001709  // Usage : I2C_Ack();
001506  001710  // Notes : generates the acknowledge condition.
001507  001711        
001508  001712  func I2C_Nack(), 0;
001509  001713  // Syntax: I2C_Nack();
001510  001714  // Usage : I2C_Nack();
001511  001715  // Notes : generates the negative acknowledge condition.
001512  001716        
001513  001717  func I2C_AckStatus(), 0;
001514  001718  // Syntax: I2C_AckStatus();
001515  001719  // Usage : r := I2C_AckStatus();
001516  001720  // Notes : returns the ACK status from the device.
001517  001721        
001518  001722  func I2C_AckPoll("control"), 1;
001519  001723  // Syntax: I2C_AckPoll();
001520  001724  // Usage : r := I2C_AckPoll(0xA0);
001521  001725  // Notes : waits for a device to return from ACK polling.
001522  001726        
001523  001727  func I2C_Idle(), 0;
001524  001728  // Syntax: I2C_Idle();
001525  001729  // Usage : I2C_Idle();
001526  001730  // Notes : waits until the I2C Bus is Inactive.
001527  001731        
001528  001732  func I2C_Gets("buffer", "size"), 1;
001529  001733  // Syntax: I2C_Gets("buffer", "size");
001530  001734  // Usage : r := I2C_Gets(mybuf, 16);
001531  001735  // Notes : only reads up to "size" characters into "buffer"
001532  001736  //       : Reads up to asciiz terminator including terminator
001533  001737        
001534  001738  func I2C_Getn("buffer", "size"), 1;
001535  001739  // Syntax: I2C_Gets("buffer", "size");
001536  001740  // Usage : r := I2C_Gets(mybuf, 16);
001537  001741  // Notes : reads "size" bytes into "buffer"
001538  001742  //       :
001539  001743        
001540  001744  func I2C_Puts("buffer"), 1;
001541  001745  // Syntax: I2C_Puts("buffer");
001542  001746  // Usage : r := I2C_Puts(mybuf);
001543  001747  // Notes : writes an asciiz string to the I2C device
001544  001748  //       : returns count of characters written
001545  001749        
001546  001750  func I2C_Putn("buffer", "count"), 1;
001547  001751  // Syntax: I2C_Putn("buffer","count");
001548  001752  // Usage : r := I2C_Puts(mybuf,10);
001549  001753  // Notes : writes up to "size" bytes to the I2C device
001550  001754  //       : returns number of bytes written
001551  001755        
001552  001756        
001553  001757  //------------------------------------------------------------------//
001554  001758  //        Image Control Function Prototypes
001555  001759  //------------------------------------------------------------------//
001556  001760  func img_SetPosition("handle", "index", "xpos", "ypos"), 1;
001557  001761  // Syntax: img_SetPosition(handle, index, xpos, ypos);
001558  001762  // Usage : r := img_SetPosition(hImageList, imagenum, x, y);
001559  001763  // Notes : set the position where the image will be displayed
001560  001764  //       : returns true if index was ok and function was successful.
001561  001765  //       : you may turn off an image so when img_Refresh is called,
001562  001766  //       : the image will not be shown
001563  001767        
001564  001768  func img_Enable("handle", "index"), 1;
001565  001769  // Syntax: img_Enable(handle, index);
001566  001770  // Usage : r := img_Enable(hImageList, imagenum);
001567  001771  // Notes : enable image in a image list
001568  001772  //       : returns true if index was ok and function was successful.
001569  001773  //       : this is the default state so when img_Refresh is called,
001570  001774  //       : all the images in the list will be shown
001571  001775  //       : if index is set to -1, all of the images are enabled
001572  001776        
001573  001777  func img_Disable("handle", "index"), 1;
001574  001778  // Syntax: img_Disable(handle, index);
001575  001779  // Usage : r := img_Disable(hImageList, imagenum);
001576  001780  // Notes : disable image in a image list
001577  001781  //       : returns true if index was ok and function was successful.
001578  001782  //       : you must turn off an image so when img_Refresh is called,
001579  001783  //       : the image will not be shown.
001580  001784  //       : if index is set to -1, all of the images are disabled
001581  001785        
001582  001786        
001583  001787  func img_Darken("handle", "index"), 1;
001584  001788  // Syntax: img_Darken(handle, index);
001585  001789  // Usage : r := img_Darken(hImageList, imagenum);
001586  001790  // Notes : darken image in a image list
001587  001791  //       : returns true if index was ok and function was successful.
001588  001792  //       : if index is set to -1, all of the images are darkened
001589  001793  //       : NB:- this feature will only work for the next refresh, then
001590  001794  //       : the image reverts back to normal when displayed again.
001591  001795        
001592  001796        
001593  001797  func img_Lighten("handle", "index"), 1;
001594  001798  // Syntax: img_Lighten(handle, index);
001595  001799  // Usage : r := img_Lighten(hImageList, imagenum);
001596  001800  // Notes : lighten image in a image list
001597  001801  //       : returns true if index was ok and function was successful.
001598  001802  //       : if index is set to -1, all of the images are lightened
001599  001803  //       : NB:- this feature will only work for the next refresh, then
001600  001804  //       : the image reverts back to normal when displayed again.
001601  001805        
001602  001806  func img_SetWord("handle", "index", "offset", "word"), 1;
001603  001807  // Syntax: img_SetWord(handle, index, offset, word);
001604  001808  // Usage : img_SetWord(hndl, 5, IMAGE_XPOS, 10);
001605  001809  // Notes : set specified word (0-7) in a image entry
001606  001810  //       : returns TRUE if successful, return value usually ignored.
001607  001811        
001608  001812  func img_GetWord("handle", "index", "offset"), 1;
001609  001813  // Syntax: myvar := img_GetWord("handle", "index", "offset");
001610  001814  // Usage : myvar := img_GetWord(hndl, 5, IMAGE_YPOS);
001611  001815  // Notes : returns specified word (0-14) from an image entry
001612  001816  //       : refer to image control entry offsets.
001613  001817        
001614  001818  func img_Show("handle", "index"), 1;
001615  001819  // Syntax: img_Show(handle, index);
001616  001820  // Usage : display image entry (regardless of enable/disable)
001617  001821  //       : returns TRUE if successful, return value usually ignored.
001618  001822        
001619  001823  func img_SetAttributes("handle", "index","value"), 1;
001620  001824  // Syntax: img_SetAttributes("handle", "index","offset");
001621  001825  // Usage : img_SetAttributes(hndl, 5, I_TOPMOST);
001622  001826  // Notes : This function SETS one or more bits in the IMAGE_FLAGS field
001623  001827  //       : of an image control entry. "value" refers to various bits in
001624  001828  //       : the image control entry (see image attribute flags).
001625  001829  //       : A '1' bit in the "value" field SETS the respective bit
001626  001830  //       : in the IMAGE_FLAGS field of the image control entry.
001627  001831  //       : returns TRUE if successful, return value usually ignored.
001628  001832        
001629  001833  func img_ClearAttributes("handle", "index","value"), 1;
001630  001834  // Syntax: img_ClearAttributes("handle", "index","offset");
001631  001835  // Usage : img_ClearAttributes(hndl, 5, I_TOPMOST);
001632  001836  // Notes : This function CLEARS one or more bits in the IMAGE_FLAGS field
001633  001837  //       : of an image control entry. "value" refers to various bits in
001634  001838  //       : the image control entry (see image attribute flags)
001635  001839  //       : a '1' bit in the "value" field CLEARS the respective bit
001636  001840  //       : in the IMAGE_FLAGS field of the image control entry.
001637  001841  //       : returns TRUE if successful, return value usually ignored.
001638  001842        
001639  001843  func img_Touched("handle", "index"), 1;
001640  001844  // Syntax: r := img_Touched(handle, index);
001641  001845  // Usage : img_Touched(hndl, 17);
001642  001846  //       : returns -1 if image not touched, or returns index
001643  001847  // Notes : if index is passed as -1, function tests all images,
001644  001848  //       : and returns -1 if image not touched, or returns index.
001645  001849        
001646  001850        
001647  001851        
001648  001852        
001649  001853  //------------------------------------------------------------------//
001650  001854  //        Timer Function Prototypes
001651  001855  //------------------------------------------------------------------//
001652  001856  func sys_T(), 1;
001653  001857  // Syntax: sys_T();
001654  001858  // Usage : t := sys_T();
001655  001859  // Notes : return the current value of the rolling system timer (1msec) LO word
001656  001860        
001657  001861  func sys_T_HI(), 1;
001658  001862  // Syntax: sys_T_HI();
001659  001863  // Usage : t := sys_T_HI();
001660  001864  // Notes : return the current value of the rolling system timer (1msec) HI word
001661  001865        
001662  001866  func sys_SetTimer("timernum","value"), 0;
001663  001867  // Syntax: sys_SetTimer("timernum", "value");
001664  001868  // Usage : sys_SetTimer(TIMER5, 10000);
001665  001869  // Notes : set a countdown on the selected timer, or 'top up' if required.
001666  001870  //       : There ar 8 timers TIMER0 to TIMER7 which stop at the count of 0
001667  001871  //       : Maximum timeout period is 65.535 seconds
001668  001872  //       : A timer can be read with the sys_GetTimer("timernum") function
001669  001873        
001670  001874  func sys_GetTimer("timernum"), 1;
001671  001875  // Syntax: t := sys_GetTimer("timernum");
001672  001876  // Usage : t := sys_GetTimer(TIMER3);
001673  001877  // Notes : returns 0 if timer has expired, or the current countdown value.
001674  001878  //       : There ar 8 timers TIMER0 to TIMER7 which stop at the count of 0
001675  001879  //       : Maximum timeout period is 65.535 seconds
001676  001880  //       : A timer must be set with the sys_SetTimer("timernum","value") function
001677  001881        
001678  001882  func sys_SetTimerEvent("timernum","function"), 1;
001679  001883  // Syntax: sys_SetTimerFunction("timernum", "function");
001680  001884  // Usage : sys_SetTimer(TIMER5, myfunc);
001681  001885  // Notes : set a function to be called for selected timer.
001682  001886  //       : When the timer reaches zero, the function is called.
001683  001887  //       : The called function must not have any parameters
001684  001888  //       : sys_SetTimerEvent returns any previous event function
001685  001889  //       : address, or zero if there was no previous function.
001686  001890        
001687  001891  func sys_EventQueue(), 1;
001688  001892  // Syntax: sys_EventQueue();
001689  001893  // Usage : tasks := sys_EventQueue();
001690  001894  // Notes : returns the max number of events that were pending
001691  001895  //       : in the timer queue since the last call to this function.
001692  001896  //       : This can be used to assess timer event overhead burden,
001693  001897  //       : especially after or during a sys_EventsPostpone action.
001694  001898        
001695  001899  func sys_EventsPostpone(), 0;
001696  001900  // Syntax: sys_EventPostpone();
001697  001901  // Usage : sys_EventPostpone();   // postpone the event queue
001698  001902  // Notes : postpone any events until the sys_EventResume function is executed
001699  001903  //       : The timer event queue will continue to queue events, but no action
001700  001904  //       : will take place untill a sys_EventResume function is encountered.
001701  001905  //       : The queue will continue to receive up to 32 events before discarding
001702  001906  //       : any further events. This function is required to allow a sequence of
001703  001907  //       : instructions or functions to occur that would otherwise be corrupted
001704  001908  //       : by an event occuring during the sequence of instructions or functions.
001705  001909  //       : A good example of this is when you set a position to print, if there
001706  001910  //       : was no way of locking the current sequence, an event may occur which
001707  001911  //       : does a similar thing, and a contention would occur - printing to
001708  001912  //       : the wrong position. This function should be used wisely, if any action
001709  001913  //       : that is required would take considerable time, it is better to disable
001710  001914  //       : any conflicting event functions with a bypass flag, then restart the
001711  001915  //       : conflicting event by re-issuing a timer value.
001712  001916        
001713  001917  func sys_EventsResume(), 0;
001714  001918  // Syntax: sys_EventsResume();
001715  001919  // Usage : sys_EventsResume();   // resume the event queue
001716  001920  // Notes : resume any postponed events. The queue will try to execute any timer
001717  001921  //       : events that were incurred during the postponed period.
001718  001922        
001719  001923        
001720  001924  func sys_Sleep("units"), 1;
001721  001925  // Syntax: t := sys_Sleep("units");
001722  001926  // Usage : t := sys_Sleep(10);
001723  001927  // Notes : sets the display into low power mode for a period of time.
001724  001928  //       : Touching the touch screen will also wake from sleep.
001725  001929  //       : Returns remaining sleep units.
001726  001930        
001727  001931  func iterator("offset"), 0;
001728  001932  // Syntax: t :=  iterator("offset");
001729  001933  // Usage : t :=  iterator(10);
001730  001934  // Notes : set the iterator size for ++/--
001731  001935  //       : The next postinc,postdec,preinc of predec will alter
001732  001936  //       : by the specified value.
001733  001937  //       : The offset will return to 1 after the next operation.
001734  001938        
001735  001939        
001736  001940        
001737  001941        
001738  001942  //------------------------------------------------------------------//
001739  001943  //         Touch Screen Function Prototypes
001740  001944  //------------------------------------------------------------------//
001741  001945        
001742  001946  func touch_DetectRegion("x1" ,"y1", "x2", "y2"), 0;
001743  001947  // Syntax: touch_DetectRegion(x1, y1, x2, y2);
001744  001948  // Usage : touch_DetectRegion(arg1, arg2, arg3, arg4);
001745  001949  // Notes : Specifies a new touch detect region on the screen
001746  001950  //       : such that only touch activity in that region will
001747  001951  //       : be reported by the status poll touch_Get(TOUCH_STATUS);
001748  001952        
001749  001953  func touch_Set("mode"), 0;
001750  001954  // Syntax: touch_Set(mode);
001751  001955  // Usage : touch_Set(arg);
001752  001956  // Notes : Sets various Touch Screen related parameters
001753  001957  //       :
001754  001958  //       : mode = TOUCH_ENABLE (mode 0)  Enable Touch Screen
001755  001959  //       : touch_Set(TOUCH_ENABLE);
001756  001960  //       : Enables and initialises Touch Screen hardware
001757  001961  //       :
001758  001962  //       : mode = TOUCH_DISABLE (mode 1)  Disable Touch Screen
001759  001963  //       : touch_Set(TOUCH_DISABLE );
001760  001964  //       : Disables the Touch Screen
001761  001965  //       : Note: Touch Screen runs in the background and disabling
001762  001966  //       : it when not in use will free up extra resources
001763  001967  //       : such as 4DVM CPU cycles.
001764  001968  //       :
001765  001969  //       : mode = TOUCH_REGIONDEFAULT (mode 2)  Default Touch Region
001766  001970  //       : touch_Set(TOUCH_REGIONDEFAULT);
001767  001971  //       : This will reset the current active region to default
001768  001972  //       : to the full screen without the application having to
001769  001973  //       : set a new active region for the full screen.
001770  001974  //       : (NB for 'no touch' devices - like uVGAII or OLED's/LCD's
001771  001975  //       : that requre to be interfaced with an external pointing
001772  001976  //       : device, values that are poked into TOUCH_DRIVE will be
001773  001977  //       : read with the touch_Get() function)
001774  001978        
001775  001979        
001776  001980  func touch_Get("mode"), 1;
001777  001981  // Syntax: touch_Get(mode);
001778  001982  // Usage : arg1 := touch_Get(arg);
001779  001983  // Notes : Returns various Touch Screen parameters to caller
001780  001984  //       :
001781  001985  //       : mode = TOUCH_STATUS  (mode 0)
001782  001986  //       : var := touch_Get(TOUCH_STATUS);
001783  001987  //       : Returns the various states of the touch screen
001784  001988  //       : 0 = NOTOUCH
001785  001989  //       : 1 = TOUCH_PRESSED
001786  001990  //       : 2 = TOUCH_RELEASED
001787  001991  //       : 3 = TOUCH_MOVING
001788  001992  //       :
001789  001993  //       : mode = TOUCH_GETX   (mode 1)
001790  001994  //       : var := touch_Get(TOUCH_GETX);
001791  001995  //       : Returns the X coordinates of the touch
001792  001996  //       :
001793  001997  //       : mode = TOUCH_GETY   (mode 2)
001794  001998  //       : var := touch_Get(TOUCH_GETY);
001795  001999  //       : Returns the Y coordinates of the touch
001796  002000        
001797  002001  //------------------------------------------------------------------//
001798  002002  //        CTYPE Function Prototypes
001799  002003  //------------------------------------------------------------------//
001800  002004        
001801  002005  func isdigit("char"), 1;    //Returns a 1 if the character is an ascii digit else returns a 0
001802  002006  // Syntax: isdigit("char");
001803  002007  // Usage : Var := isdigit(ch);
001804  002008  // Notes : char specifies the ascii character for the test
001805  002009  //     : 0 : char is not an ascii digit.
001806  002010  //     : 1 : char is an ascii digit..
001807  002011  //     : Valid range is "0123456789"
001808  002012        
001809  002013  func isxdigit("char"), 1;    //Returns a 1 if the character is an ascii hexadecimal digit else returns a 0
001810  002014  // Syntax: isxdigit("char");
001811  002015  // Usage : Var := isxdigit(ch);
001812  002016  // Notes : char specifies the ascii character for the test
001813  002017  //     : 0 : char is not an ascii hexadecimal digit.
001814  002018  //     : 1 : char is an ascii hexadecimal digit..
001815  002019  //     : Valid range is "0123456789ABCDEF"
001816  002020        
001817  002021  func isupper("char"), 1;    //Returns a 1 if the character is an ascii upper case letter else returns a 0
001818  002022  // Syntax: isupper("char");
001819  002023  // Usage : Var := isupper(ch);
001820  002024  // Notes : char specifies the ascii character for the test
001821  002025  //     : 0 : char is not an ascii upper-case letter.
001822  002026  //     : 1 : char is an ascii upper-case letter.
001823  002027  //     : Valid range is "ABCD....WXYZ"
001824  002028        
001825  002029  func islower("char"), 1;    //Returns a 1 if the character is an ascii lower case letter else returns a 0
001826  002030  // Syntax: islower("char");
001827  002031  // Usage : Var := islower(ch);
001828  002032  // Notes : char specifies the ascii character for the test
001829  002033  //     : 0 : char is not an ascii lower-case letter.
001830  002034  //     : 1 : char is an ascii lower-case letter.
001831  002035  //     : Valid range is "abcd....wxyz"
001832  002036        
001833  002037  func isalpha("char"), 1;    //Returns a 1 if the character is an ascii lower or upper case letter else returns a 0
001834  002038  // Syntax: isalpha("char");
001835  002039  // Usage : Var := isalpha(ch);
001836  002040  // Notes : char specifies the ascii character for the test
001837  002041  //     : 0 : char is not an ascii lower or upper case letter.
001838  002042  //     : 1 : char is an ascii lower or upper case letter.
001839  002043  //     : Valid range is "ABCD...XYZ", "abcd....wxyz"
001840  002044        
001841  002045  func isalnum("char"), 1;    //Returns a 1 if the character is an ascii alpha numeric else returns a 0
001842  002046  // Syntax: isalnum("char");
001843  002047  // Usage : Var := isalnum(ch);
001844  002048  // Notes : char specifies the ascii character for the test
001845  002049  //     : 0 : char is not an ascii alphanumeric character.
001846  002050  //     : 1 : char is an ascii alphanumeric character.
001847  002051  //     : Valid range is "ABCD...XYZ", "abcd....wxyz", "0123456789"
001848  002052        
001849  002053  func isprint("char"), 1;    //Returns a 1 if the character is a printible ascii char else returns a 0
001850  002054  // Syntax: isprint("char");
001851  002055  // Usage : Var := isprint(ch);
001852  002056  // Notes : char specifies the ascii character for the test
001853  002057  //     : 0 : char is not a printable ascii character.
001854  002058  //     : 1 : char is a printable ascii character.
001855  002059  //     : Valid range is "0x20...0x7F"
001856  002060        
001857  002061  func isspace("char"), 1;    //Returns a 1 if the character is any one of the space type chars else returns a 0
001858  002062  // Syntax: isspace("char");
001859  002063  // Usage : Var := isspace(ch);
001860  002064  // Notes : char specifies the ascii character for the test
001861  002065  //     : 0 : char is not a space type character.
001862  002066  //     : 1 : char is a space type character.
001863  002067  //     : Valid range is space, formfeed, newline, carriage return, tab, vertical tab
001864  002068        
001865  002069  //unformatted
001866  002070  func iswhite("char"), 1;    //
001867  002071  // Syntax: iswhite("char");
001868  002072  // Usage : Var := iswhite(ch);
001869  002073  // Notes : char specifies the ascii character for the test
001870  002074  //     : 0 : char is not a space or tab character.
001871  002075  //     : 1 : char is not a space or tab character.
001872  002076  //     : Valid range is space or tab
001873  002077        
001874  002078  func toupper("char"), 1; //if character is lower case it returns the upper case equivalent else returns the passed char
001875  002079  // Syntax: toupper("char");
001876  002080  // Usage : Var := toupper(ch);
001877  002081  // Notes : char specifies the ascii character for the test
001878  002082  //     : "ABCD....XYZ" : if character is a lower case letter.
001879  002083  //     : char : if character is not a lower case letter.
001880  002084  //     : Valid range is "abcd....wxyz"
001881  002085        
001882  002086  func tolower("char"), 1; //if character is upper case it returns the lower case equivalent else returns the passed char
001883  002087  // Syntax: tolower("char");
001884  002088  // Usage : Var := tolower(ch);
001885  002089  // Notes : char specifies the ascii character for the test
001886  002090  //     : "abcd....xyz" : if character is an upper case letter.
001887  002091  //     : char : if character is not an upper case letter.
001888  002092  //     : Valid range is "ABCD....WXYZ"
001889  002093        
001890  002094  func LObyte("var"), 1;        //Returns the lower byte (lower 8 bits) of a 16 bit variable.
001891  002095  // Syntax: LObyte(var);
001892  002096  // Usage : myVar := LObyte(myvar2);
001893  002097  // Notes : var specifies the user variable
001894  002098  //     : Returns the lower byte (lower 8 bits) of a 16 bit variable
001895  002099        
001896  002100  func HIbyte("var"), 1;        //Returns the High byte (upper 8 bits) of a 16 bit variable.
001897  002101  // Syntax: HIbyte(var);
001898  002102  // Usage : myVar := HIbyte(myvar2);
001899  002103  // Notes : var specifies the user variable
001900  002104  //     : Returns the high byte (upper 8 bits) of a 16 bit variable
001901  002105        
001902  002106        
001903  002107  func ByteSwap("var"), 1;    //Returns the swapped upper and lower bytes of a 16 bit variable.
001904  002108  // Syntax: ByteSwap(var);
001905  002109  // Usage : myVar := ByteSwap(myvar2);
001906  002110  // Notes : var specifies the user variable
001907  002111  //     : Returns the endian swapped value of a 16 bit variable
001908  002112        
001909  002113        
001910  002114  //------------------------------------------------------------------//
001911  002115  //        Memory Allocation Function Prototypes
001912  002116  //------------------------------------------------------------------//
001913  002117        
001914  002118  func mem_Alloc("size"), 1;
001915  002119  // Syntax: mem_Alloc(bytesize);
001916  002120  // Usage : myvar := mem_Alloc(100);
001917  002121  // Notes : Allocate a block of memory to pointer myvar
001918  002122  //       : The allocated memory contains garbage but is a fast allocation.
001919  002123  //       : The block must later be released with mem_Free();
001920  002124  //       : returns 0 if function fails
001921  002125        
001922  002126  func mem_AllocV("size"), 1;
001923  002127  // Syntax: mem_AllocV(bytesize);
001924  002128  // Usage : myvar := mem_AllocV(100);
001925  002129  // Notes : Allocate a block of memory to pointer myvar
001926  002130  //       : The block of memory is filled with signature values
001927  002131  //       : the block starts with A5,5A then fills with incrementing
001928  002132  //       : number eg:- A5,5A,00,01,02,03...FF,00,11....
001929  002133  //       : This can be helpful when debugging
001930  002134  //       : The block must later be released with mem_Free();
001931  002135  //       : returns 0 if function fails
001932  002136        
001933  002137  func mem_AllocZ("size"), 1;
001934  002138  // Syntax: mem_AllocZ(bytesize);
001935  002139  // Usage : myvar := mem_AllocC(100);
001936  002140  // Notes : Allocate a zeroed block of memory to pointer myvar
001937  002141  //       : The block of memory is filled with zeroes
001938  002142  //       : The block must later be released with mem_Free();
001939  002143  //       : returns 0 if function fails
001940  002144        
001941  002145  func mem_Realloc("ptr", "size"), 1;
001942  002146  // Syntax: myvar := mem_Realloc("ptr", "size");
001943  002147  // Usage : myvar := mem_Realloc(ptr, size);
001944  002148  // Notes : The function may move the memory block to a new location,
001945  002149  //       : in which case the new location is returned.
001946  002150  //       : The content of the memory block is preserved up to the lesser
001947  002151  //       : of the new and old sizes, even if the block is moved.
001948  002152  //       : If the new size is larger, the value of the newly allocated
001949  002153  //       : portion is indeterminate. In case that ptr is NULL,
001950  002154  //       : the function behaves exactly as mem_Alloc, assigning a new block
001951  002155  //       : of size bytes and returning a pointer to the beginning of it.
001952  002156  //       : In case that the size is 0, the memory previously allocated in
001953  002157  //       : ptr is deallocated as if a call to mem_Free()was made, and a NULL
001954  002158  //       : pointer is returned.
001955  002159        
001956  002160  func mem_Free("allocation"), 1;
001957  002161  // Syntax: myvar := mem_Free(allocation);
001958  002162  // Usage : myvar := mem_Free(myvar);
001959  002163  // Notes : De-allocate a block of memory previously created with
001960  002164  //       : mem_Alloc(...), mem_AllocV(...); or mem_AllocZ(...);
001961  002165  //       : returns 0 if function fails
001962  002166        
001963  002167  func mem_Heap(), 1;
001964  002168  // Syntax: myvar := mem_Heap();
001965  002169  // Usage : myvar := mem_Heap();
001966  002170  // Notes : returns bytecount available in heap
001967  002171  //       :
001968  002172        
001969  002173  func mem_Set("ptr","char","size"), 1;
001970  002174  // Syntax: mem_Set(ptr,char,bytesize);
001971  002175  // Usage : mem_Set(p, 'A', 100);
001972  002176  // Notes : fill a block of memory with a byte value
001973  002177  //       : returns ptr
001974  002178        
001975  002179  func mem_Copy("src", "dest", "bytecount"), 1;
001976  002180  // Syntax: myvar := mem_Copy(src, dest, bytesize);
001977  002181  // Usage : myvar := mem_Copy(p1, p2, 100);
001978  002182  // Notes : copy a word aligned block of memory from src to dest
001979  002183  //       : Note that count is a byte count, this facilitates
001980  002184  //       : copying word aligned byte arrays when using word
001981  002185  //       : aliggned packed strings.
001982  002186  //       : returns src
001983  002187        
001984  002188  func mem_Compare("ptr1","ptr2","count"), 1;
001985  002189  // Syntax: myvar := mem_Compare(ptr1,ptr2,bytesize);
001986  002190  // Usage : myvar := mem_Compare(p1, p2, 100);
001987  002191  // Notes : compare blocks of memory at src, dest
001988  002192  //       : returns 0 if we have a match
001989  002193        
001990  002194  //------------------------------------------------------------------//
001991  002195  //        FAT16 Function Prototypes
001992  002196  //------------------------------------------------------------------//
001993  002197        
001994  002198  func file_Error(), 1;
001995  002199  // Syntax: myvar := file_Error();
001996  002200  // Usage : e := file_Error();
001997  002201  // Notes : return the most recent file error.
001998  002202  //       :
001999  002203        
002000  002204  func file_Count("filename"), 1;
002001  002205  // Syntax: count := file_Count("filename");
002002  002206  // Usage : count := file_Count("*.4dg");
002003  002207  // Notes : returns number of files found that match the criteria
002004  002208        
002005  002209  func file_Dir("filename"), 1;
002006  002210  // Syntax: count := file_Dir("filename");
002007  002211  // Usage : count := file_Dir("*.4dg");
002008  002212  // Notes : streams a string of filenames that agree with the search key
002009  002213  //       : returns number of files found that match the criteria
002010  002214        
002011  002215  func file_FindFirst("fname"), 1;
002012  002216  // Syntax: res := file_FindFirst("fname");
002013  002217  // Usage : if (file_FindFirst("*.4xe") ....
002014  002218  // Notes : returns true if at least 1 file exists
002015  002219  //       : that satisfies the file argument.
002016  002220  //       : Wildcards are usually used so if
002017  002221  //       : file_FindFirst returns true, further
002018  002222  //       : tests can be made using file_FindNext();
002019  002223  //       : to find all the files that match the
002020  002224  //       : wildcard class. Note that the stream behaviour
002021  002225  //       : is the same as file_Dir.
002022  002226  //       :
002023  002227        
002024  002228  func file_FindNext(), 1;
002025  002229  // Syntax: res := file_FindNext();
002026  002230  // Usage : while ((file_FindNext()) ....
002027  002231  // Notes : returns true if more file exists
002028  002232  //       : that satisfies the file argument
002029  002233  //       : that was given for  file_FindFirst.
002030  002234  //       : Wildcards must be used for
002031  002235  //       : file_FindFirst, else this function will
002032  002236  //       : always return zero as the only occurence
002033  002237  //       : will have already been found.
002034  002238  //       : Note that the stream behaviour
002035  002239  //       : is the same as file_Dir.
002036  002240  //       :
002037  002241        
002038  002242  func file_Exists("fname"), 1;
002039  002243  // Syntax: res := file_Exists("fname"),
002040  002244  // Usage : if(file_Exists("myfile") ....
002041  002245  // Notes : returns true if file exists
002042  002246  //       :
002043  002247        
002044  002248  func file_Open("fname", "mode"), 1;
002045  002249  // Syntax: handle := file_Open("fname","mode"),
002046  002250  // Usage : handle := file_Open("myfile.txt", 'r');
002047  002251  // Notes : returns handle if file exists
002048  002252  //       :
002049  002253        
002050  002254  func file_Close("handle"), 1;
002051  002255  // Syntax: res := file_Close("handle");
002052  002256  // Usage : res := file_Close(hnd1);
002053  002257  // Notes : returns true if file closed ok
002054  002258  //       :
002055  002259        
002056  002260  func file_Read("*dest", "size", "handle"), 1;
002057  002261  // Syntax: res := file_Read("*dest", "size", "handle"),
002058  002262  // Usage : res := file_Read(memblock,20,hnd1);
002059  002263  // Notes : returns number of characters read
002060  002264  //       : if "dest" is zero, data is read direct to GRAM window
002061  002265  //       :
002062  002266        
002063  002267        
002064  002268  func file_Seek("handle", "HiWord", "LoWord"), 1;
002065  002269  // Syntax: res := file_Seek("handle", "HiWord", "LoWord")
002066  002270  // Usage : res := file_Seek(hSource, 0, 0x1234);
002067  002271  // Notes : set file position to 0x00001234 (byte position 4660)
002068  002272  //       : for the file handle so subsequent data may be read
002069  002273  //       : from that position onwards with file_GetC(...),
002070  002274  //       : file_GetW(...) or file_GetS(...), or an image
002071  002275  //       : can be displayed with file_Image(...)
002072  002276  // Notes : returns true if ok, usually ignored
002073  002277        
002074  002278  func file_Index("handle", "HiSize", "LoSize","recordnum"), 1;
002075  002279  // Syntax: file_Index("handle", "HiSize", "LoSize","recordnum"), 1;
002076  002280  // Usage : res := file_Index(hsource, 0, 1000, 123), 1;
002077  002281  // Notes : set file seek position to 123000
002078  002282  //       : for the file handle so subsequent data may be read
002079  002283  //       : from that record position onwards with file_GetC(...),
002080  002284  //       : file_GetW(...) or file_GetS(...), or an image
002081  002285  //       : can be displayed with file_Image(...)
002082  002286  // Notes : returns true if ok, usually ignored
002083  002287        
002084  002288  func file_Tell("handle", "&HiWord", "&LoWord"), 1;
002085  002289  // Syntax: file_Tell("handle", &HiWord, &LoWord);
002086  002290  // Usage : file_Tell(fhndl, &SizeHi, &SizeLo);
002087  002291  // Notes : Reads the 32 bit file pointer and stores it into 2 variables.
002088  002292  //       : returns true if function succeeded
002089  002293        
002090  002294  func file_Write("*source", "size", "handle"), 1;
002091  002295  // Syntax: res := fwrite("*source", "size", "handle"),
002092  002296  // Usage : res := fwrite(memblock, 20, hnd1);
002093  002297  // Notes : returns number of bytes written
002094  002298  //       :
002095  002299        
002096  002300  func file_Size("handle", "&HiWord", "&LoWord"), 1;
002097  002301  // Syntax: file_Size("handle", &HiWord, &LoWord);
002098  002302  // Usage : file_Size(fhndl, &SizeHi, &SizeLo);
002099  002303  // Notes : Reads the 32 bit file size and stores it into 2 variables.
002100  002304  //       : returns true if function succeeded
002101  002305        
002102  002306  func file_Image("x", "y", "handle"), 1;
002103  002307  // Syntax: file_Image(x, y, handle);
002104  002308  // Usage : file_Image(10, 10, hnd1);
002105  002309  // Notes : Display an image from a file at the current file position.
002106  002310  //       : The image is displayed at x,y (with respect to top left corner).
002107  002311  //       : If there is more than 1 image in the file, it can be
002108  002312  //       : accessed with file_Seek(...)
002109  002313        
002110  002314  func file_ScreenCapture("x", "y", "width", "height", "handle"), 1;
002111  002315  // Syntax: file_ScreenCapture(x, y, w, h, handle);
002112  002316  // Usage : file_ScreenCapture(10, 10, 50,50, hnd1);
002113  002317  // Notes : Save a image from screen to file at the current file position.
002114  002318  //       : The image can later be displayed with file_Image(...);
002115  002319  //       : The file may be opened in append mode to accumulate multiple
002116  002320  //       : images. Later, the images can be accessed with file_Seek(...);
002117  002321  //       : Note that the image will be sector aligned.
002118  002322  //       : All image headers must start on a sector boundary.
002119  002323  //       : The image is saved from x, y (with respect to top left corner)
002120  002324  //       : and the capture area is determined by "width" and "height".
002121  002325  //       : returns 0 if function succeeded
002122  002326        
002123  002327  func file_PutC("char","handle"), 1;
002124  002328  // Syntax: file_PutC("char", "handle");
002125  002329  // Usage : file_PutC('x', hndl);
002126  002330  // Notes : returns true if function succeeded
002127  002331        
002128  002332  func file_GetC("handle"), 1;
002129  002333  // Syntax: file_GetC("handle");
002130  002334  // Usage : mychar := fgetC("handle");
002131  002335  // Notes : returns next char from file
002132  002336        
002133  002337  func file_PutW("word","handle"), 1;
002134  002338  // Syntax: file_PutW("word","handle");
002135  002339  // Usage : file_PutW(0x1234, hndl);
002136  002340  // Notes : returns true if function succeeded
002137  002341        
002138  002342  func file_GetW("handle"), 1;
002139  002343  // Syntax: file_GetW("handle");
002140  002344  // Usage : myword := fgetW("handle");
002141  002345  // Notes : returns next word in file
002142  002346        
002143  002347  func file_PutS("*source", "handle"), 1;
002144  002348  // Syntax: res := file_Puts("*source", "handle"),
002145  002349  // Usage : res := file_Puts(mystring, hnd1);
002146  002350  // Notes : returns number of characters written
002147  002351  //       :
002148  002352        
002149  002353  func file_GetS("*string", "size", "handle"), 1;
002150  002354  // Syntax: res := file_Gets("*string", "size", "handle");
002151  002355  // Usage : res := file_Gets(mystr , 81, hnd1); // read up to 80 chars
002152  002356  // Notes : get a string from a file
002153  002357  //       : returns pointer to string or null if failed.
002154  002358  //       : file_GetS(...) automatically appends a null-terminator to the data read.
002155  002359  //       : NB:- only reads up to "size-1" characters into "string"
002156  002360  //       : file_GetS(...) will stop reading when any of the following conditions are true:
002157  002361  //       : A] It has read n-1 bytes (one character is reserved for the null-terminator)
002158  002362  //       : B] It encounters a newline character (a line-feed in the compilers tested here), or
002159  002363  //       : C] It reaches the end of file
002160  002364  //       : D] A read error occurs.
002161  002365        
002162  002366        
002163  002367  func file_Erase("fname"), 1;
002164  002368  // Syntax: res := file_Erase("fname");
002165  002369  // Usage : res := file_Erase("myfile.txt");
002166  002370  // Notes : returns true if successful
002167  002371  //       :
002168  002372        
002169  002373  func file_Rewind("handle"), 1;
002170  002374  // Syntax: res := file_Rewind("handle");
002171  002375  // Usage : res := file_Rewind(hnd1);
002172  002376  // Notes : returns true if file rewound ok (usually ignored)
002173  002377  //       : resets the file pointer the the beginning of the open file.
002174  002378        
002175  002379  func file_LoadFunction("fname.4xe"), 1;
002176  002380  // Syntax: res := file_LoadFunction("fname.4fn");
002177  002381  // Usage : myfunc := file_LoadFunction(myfuncname);
002178  002382  // Notes : Load a function or program from disk and
002179  002383  //       : return a function pointer to the allocation.
002180  002384  //       : The function can then be invoked just like any other
002181  002385  //       : function would be called via a function pointer.
002182  002386  //       : Parameters may be passed to it in a conventional way.
002183  002387  //       : The function may be discarded at any time when no
002184  002388  //       : longer required, thus freeing its memory resources.
002185  002389  //       : The loaded function can be discarded with mem_Free(..)
002186  002390  //       : eg:
002187  002391  //       : popupWindow := file_LoadFunction("popupWindow1.4fn");
002188  002392  //       : if(!popupWindow) goto LoadFunctionFailed; // could not load the function !!!
002189  002393  //       : then elsewhere in your program:-
002190  002394  //       : res := popupWindow(MYMODE,"My Title","My Popup Text");
002191  002395  //       : if(res == QUIT_APPLICATION) goto exitApp;
002192  002396  //       : Later in your program, when popupWindow is no longer
002193  002397  //       : required for the application:-
002194  002398  //       : res := mem_Free(popupWindow);
002195  002399  //       : if(!res) goto FreeFunctionFailed; // should never happen if memory not corrupted
002196  002400  //       : The callers stack is shared by the loaded function,
002197  002401  //       : however any global variables in the loaded function
002198  002402  //       : are private to that function.
002199  002403  //
002200  002404        
002201  002405  func file_Run("fname.4xe", "arglistptr"), 1;
002202  002406  // Syntax: res := file_Run("fname.4xe","arglistptr");
002203  002407  // Usage : res := file_Run(fname, argptr);
002204  002408  // Notes : current program releases any allocated memory but
002205  002409  //       : retains the stack and global memory.
002206  002410  //       : If arglistptr is 0, no arguments are passed, else
002207  002411  //       : arglist points to an array, the first element being
002208  002412  //       : the number of elements in the array.
002209  002413  //       : func 'main' in the called program accepts
002210  002414  //       : the arguments, if any. THe arguments can only
002211  002415  //       : be passed by value, no pointers or references can be
002212  002416  //       : used as all memory is cleared before the file
002213  002417  //       : is loaded. Refer to file_Exec and file_LoadFunction
002214  002418  //       : for functions that can pass by reference.
002215  002419        
002216  002420  func file_Exec("fname.4xe", "arglistptr"), 1;
002217  002421  // Syntax: res := file_Exec("fname.4xe","arglistptr");
002218  002422  // Usage : res := file_Exec("fname.4xe","arglistptr");
002219  002423  // Notes : returns like a function, current program
002220  002424  //       : calling program is kept active and control returns to it.
002221  002425  //       : If arglistptr is 0, no arguments are passed, else
002222  002426  //       : arglist points to an array, the first element being
002223  002427  //       : the number of elements in the array.
002224  002428  //       : func 'main' in the called program accepts the arguments.
002225  002429  //       : This function is similar to file_LoadFunction(...), however,
002226  002430  //       : the function argument list is passed by pointer, and
002227  002431  //       : the memory consumed by the function is released as
002228  002432  //       : soon as the function completes.
002229  002433        
002230  002434  func file_LoadImageControl("fname1", "fname2", "mode"), 1;
002231  002435  // Syntax: hImagelist := file_LoadImageControl ("controlfile", "imagefile", "mode"),
002232  002436  // Usage : hImagelist := file_LoadImageControl ("resource.dat", "resource.gci", 0);
002233  002437  // Notes : Reads a control file to create an image list.
002234  002438  //       : Returns NULL if function fails.
002235  002439  //       : Returns a handle (pointer to the memory allocation) to the
002236  002440  //       : image control list that has been created.
002237  002441  //       : "fname1" is the control list filename "*.dat"
002238  002442  //       : "fname2" is the image filename "*.gci"
002239  002443        
002240  002444  // Notes : This function Calculates the size of a chunk of memory required for
002241  002445  //       : a image list and populates it from the image control file ("*.dat")
002242  002446  //       : therefore, when imagelist is no longer required, you must de-allocate
002243  002447  //       : the image list memory by using eg:- mem_Free(hImagelist);
002244  002448  //       : to restore the heap.
002245  002449  //       :
002246  002450  //       : mode 0:- it is assumed that there is a graphics file with the
002247  002451  //       : file extension "fname2.gci". In this case, the images have been stored
002248  002452  //       : in a FAT16 file concurrently, and the offsets that ar derived from the
002249  002453  //       : "fname1.dat" file are saved in the image control so that the image control
002250  002454  //       : can open the file (*.gci) and us file_Seek to get to the position of the
002251  002455  //       : image which can then automatically be displayed using file_Image(xpos, ypos, hSource);
002252  002456  //       : mode 0 builds the image control quickly as it only scans the *.dat file
002253  002457  //       : for the file offsets and save them in the relevant entries in the image control.
002254  002458  //       : The penalty is that images take longer to find when displayed due to file_Seek
002255  002459  //       : overheads.
002256  002460  //
002257  002461  //       : mode 1:- it is assumed that there is a graphics file with the
002258  002462  //       : file extension "fname2.gci". In this case, the images have been stored
002259  002463  //       : in a FAT16 file concurrently, and the offset of the images are saved
002260  002464  //       : in the image control so that image file (*.gci) can be mapped to directly.
002261  002465  //       : The absolute cluster/sector is mapped so file seek does not need to be called
002262  002466  //       : internally. This means that there is no seek time penalty, however, the
002263  002467  //       : image list takes a lot longer to build, as all the seeking is done at control
002264  002468  //       : build time.
002265  002469        
002266  002470  //       : mode 2:- the graphics file with the is placed in a partitioned area
002267  002471  //       : In this case, the images have been stored in a in a known raw area of the FAT16
002268  002472  //       : disk, and the absolute address of the images are saved in the DAT file
002269  002473  //       : This is the fastest operation of the image control as there is no seeking
002270  002474  //       : or other disk activity taking place.
002271  002475        
002272  002476  func file_Mount(), 1;
002273  002477  // Syntax: r := file_Mount();
002274  002478  // Usage : r := file_Mount();
002275  002479  // Notes : Create a control block for FAT16 and mount the File System
002276  002480        
002277  002481  func file_Unmount(), 0;
002278  002482  // Syntax: file_Unmount();
002279  002483  // Usage : file_Unmount();
002280  002484  // Notes : release any control block and buffers for FAT16
002281  002485  //       : and unmount the File System
002282  002486        
002283  002487  func file_PlayWAV("fname1"), 1;
002284  002488  // Syntax: file_PlayWAV("fname1");
002285  002489  // Usage : file_PlayWAV("ding.wav");
002286  002490  // Notes : Play a wave file with filename "fname1"
002287  002491  //       : This function automatically grabs a chunk
002288  002492  //       : of memory for a file buffer, and a wave
002289  002493  //       : buffer. The minimum memory requirement is
002290  002494  //       : about 580 bytes for the disk io service and
002291  002495  //       : a minimum wave buffer size of 1024. The siz
002292  002496  //       : of the wave buffer allocation
002293  002497  //       : can be increased by the snd_BufSize function.
002294  002498  //       : The default size 1024 bytes.
002295  002499  //       : NB the memory is only required during the
002296  002500  //       : duration of play, and is automatically
002297  002501  //       : released while not in use.
002298  002502  //       : See the Sound Class services for other associated controls.
002299  002503  //       : If there are no errors, returns number of blocks to play (1 to 32767)
002300  002504  //       : If errors occured, the folling is returned
002301  002505  //       : -6   : cant play this rate
002302  002506  //       : -5  : no data chunk found in first rsector
002303  002507  //       : -4  : no format data
002304  002508  //       : -3  : no wave chunk signature
002305  002509  //       : -2  : bad wave file format
002306  002510  //       : -1  : file not found
002307  002511        
002308  002512        
002309  002513        
002310  002514  //------------------------------------------------------------------//
002311  002515  //        Sound Class Services
002312  002516  //------------------------------------------------------------------//
002313  002517        
002314  002518  func snd_Volume("var"), 0;
002315  002519  // Syntax: snd_Volume("var");
002316  002520  // Usage : snd_Volume(30);
002317  002521  // Notes : set sound playback volume.  Var must
002318  002522  //       : be in the range from 8 (min volume)
002319  002523  //       : to 127 (max volume). If var is less
002320  002524  //       : than 8 volume is set to 8, and if
002321  002525  //       : var > 127 it is set to 127.
002322  002526        
002323  002527  func snd_Pitch("pitch"), 1;
002324  002528  // func snd_Pitch("freq"), 1;
002325  002529  // func snd_Pitch(7000), 1; // play the wave file with a sample frequency of 7khz
002326  002530  // Notes : sets the samples playback rate to a different frequency
002327  002531  //       : The minimum value is 4khz
002328  002532  //       : Setting the pitch to zero restores the original sample rate
002329  002533  //       : Return value is the samples original sample rate.
002330  002534        
002331  002535  func snd_BufSize("var"), 0;
002332  002536  // Syntax: snd_BufSize("var");
002333  002537  // Usage : snd_BufSize(2);
002334  002538  // Notes : specify the a memory chunk size for the wavefile buffer.
002335  002539  //       : default size 1024 bytes.
002336  002540  //       : 0 = 1024 bytes (default)
002337  002541  //       : 1 = 2048 bytes
002338  002542  //       : 2 = 4096 bytes
002339  002543  //       : 3 = 8192 bytes
002340  002544        
002341  002545  func snd_Stop(), 0;
002342  002546  // Syntax: snd_Stop();
002343  002547  // Usage : snd_Stop();
002344  002548  // Notes : stop any sound that is playing, releasing
002345  002549  //       : buffers and closes any open wav file.
002346  002550        
002347  002551  func snd_Pause(), 0;
002348  002552  // Syntax: snd_Pause();
002349  002553  // Usage : snd_Pause();
002350  002554  // Notes : pauses any sound that is playing, does nothing
002351  002555  //       : until sound is resumed with snd_Continue().
002352  002556  //       : The sample cam be terminated with snd_Stop.
002353  002557  //       : buffers and closes any open wav file.
002354  002558        
002355  002559  func snd_Continue(), 0;
002356  002560  // Syntax: snd_Continue();
002357  002561  // Usage : snd_Continue();
002358  002562  // Notes : resume any sound that is paused by snd_Pause.
002359  002563        
002360  002564  func snd_Playing(), 1;
002361  002565  // Syntax: snd_Playing();
002362  002566  // Usage : r := snd_Playing();
002363  002567  // Notes : returns 0 if sound has finished playing,
002364  002568  //       : else return number of 512 byte blocks to go.
002365  002569        
002366  002570        
002367  002571        
002368  002572  //------------------------------------------------------------------//
002369  002573  //        String Class Services
002370  002574  //------------------------------------------------------------------//
002371  002575        
002372  002576  func str_Ptr("&var"), 1;
002373  002577  // Syntax: str_Ptr(&var);
002374  002578  // Usage : p := str_Ptr(&var);
002375  002579  // Notes : return a byte pointer to a word region
002376  002580        
002377  002581  func str_GetD("&ptr", "&var"), 1;
002378  002582  // Syntax: str_GetD(&ptr, &var);
002379  002583  // Usage : ok := str_GetD(&ptr, &var);
002380  002584  // Notes : convert number in a string to DWORD ( myvar[2] )
002381  002585  //       : returns true if function succeeds, advancing ptr
002382  002586        
002383  002587  func str_GetW("&ptr", "&var"), 1;
002384  002588  // Syntax: str_GetW(&ptr, &var);
002385  002589  // Usage : ok := str_GetW(&ptr, &var);
002386  002590  // Notes : convert number in a string to WORD ( myvar )
002387  002591  //       : returns true if function succeeds, advancing ptr
002388  002592        
002389  002593  func str_GetHexW("&ptr", "&var"), 1;
002390  002594  // Syntax: str_GetHexW(&ptr, &var);
002391  002595  // Usage : ok := str_GetHexW(&ptr, &var);
002392  002596  // Notes : convert HEX number in a string to WORD ( myvar )
002393  002597  //       : returns true if function succeeds, advancing ptr
002394  002598        
002395  002599  func str_GetC("&ptr", "&var"), 1;
002396  002600  // Syntax: str_GetC(&ptr, &var);
002397  002601  // Usage : ok := str_GetC(&ptr, &var);
002398  002602  // Notes : get a valid ascii char in a string to WORD ( myvar )
002399  002603  //       : returns true if function succeeds, advancing ptr
002400  002604        
002401  002605  func str_GetByte("ptr"), 1;
002402  002606  // Syntax: str_GetByte(ptr);
002403  002607  // Usage : myvar := str_GetByte(ptr);
002404  002608  // Notes : get a byte to myvar
002405  002609  //       : returns value
002406  002610        
002407  002611  func str_GetWord("ptr"), 1;
002408  002612  // Syntax: GetWord(ptr);
002409  002613  // Usage : GetWord(ptr);
002410  002614  // Notes : get a word to myvar
002411  002615  //       : returns value
002412  002616        
002413  002617  func str_PutByte("ptr","val"), 0;
002414  002618  // Syntax: str_PutByte(ptr);
002415  002619  // Usage : myvar := str_PutByte(ptr);
002416  002620  // Notes : put a byte at ptr
002417  002621  //       : returns value
002418  002622        
002419  002623  func str_PutWord("ptr","val"), 0;
002420  002624  // Syntax: str_PutWord("ptr","val");
002421  002625  // Usage : str_PutWord(p,100);
002422  002626  // Notes : put word 100 at current pointer location
002423  002627  //       : returns value
002424  002628        
002425  002629  func str_Match("&ptr", "*str"), 1;
002426  002630  // Syntax: str_Match(&ptr, *str);
002427  002631  // Usage : r := str_Match(&p, "hello");
002428  002632  // Notes : Case sensitive match
002429  002633  //       : returns true if function succeded, andvancing pointer to position past
002430  002634  //       : the matched item. Note that any whitespace characters are skipped
002431  002635  //       : in the source string prior to the test.
002432  002636        
002433  002637  func str_MatchI("&ptr", "*str"), 1;
002434  002638  // Syntax: str_MatchI(&ptr, *str);
002435  002639  // Usage : r := str_MatchI(&p, "hello");
002436  002640  // Notes : Case insensitive match
002437  002641  //       : returns true if function succeded, andvancing pointer to position past
002438  002642  //       : the matched item. Note that any whitespace characters are skipped
002439  002643  //       : in the source string prior to the test.
002440  002644        
002441  002645  func str_Find("&ptr", "*str"), 1;
002442  002646  // Syntax: str_Find(&ptr, *str);
002443  002647  // Usage : n := str_Find(&p, "hello");
002444  002648  // Notes : given the address of a pointer to a source string as the
002445  002649  //       : first argument, and a pointer to a test string as the second
002446  002650  //       : argument, attempt to find the position of the matching string
002447  002651  //       : in the source string. The test is performed with case sensitivity.
002448  002652  //       : return 0 if not found, else returns the address of the first
002449  002653  //       : character of the match. NB:- The source pointer is not altered.
002450  002654        
002451  002655  func str_FindI("&ptr", "*str"), 1;
002452  002656  // Syntax: str_Find(&ptr, *str);
002453  002657  // Usage : n := str_Find(&p, "hello");
002454  002658  // Notes : given the address of a pointer to a source string as the
002455  002659  //       : first argument, and a pointer to a test string as the second
002456  002660  //       : argument, attempt to find the position of the matching string
002457  002661  //       : in the source string. The test is performed with no case
002458  002662  //       : sensitivity, eg upper and lower case chars are accepted.
002459  002663  //       : return 0 if not found, else returns the address of the first
002460  002664  //       : character of the match. NB:- The source pointer is not altered.
002461  002665        
002462  002666  func str_Length("ptr"), 1;
002463  002667  // Syntax: str_Length(ptr);
002464  002668  // Usage : len := str_Ptr(mystring);
002465  002669  // Notes : return the length of a byte aligned string excluding terminator
002466  002670        
002467  002671  func str_Printf("&ptr", "*format"), 1;
002468  002672  // Syntax: str_Printf("&ptr", "*format");
002469  002673  // Usage : r := str_Printf(&p, "hello");
002470  002674  // Notes : refer to documentation
002471  002675  //       :
002472  002676        
002473  002677  func str_Cat("dest","src"), 1;
002474  002678  // Syntax: str_Append("&dest","&src");
002475  002679  // Usage : str_Append(&buf,"Hello");
002476  002680  // Notes : Appends a copy of the source string to the destination string.
002477  002681  //       : The terminating null character in destination is overwritten by
002478  002682  //       : the first character of source, and a new null-character is appended
002479  002683  //       : at the end of the new string formed by the concatenation of both in destination.
002480  002684  //       : returns destination.
002481  002685        
002482  002686  func str_CatN("dest","src","count"), 1;
002483  002687  // Syntax: str_Append("&dest","&src","count");
002484  002688  // Usage : str_Append(&buf,"Monday",3);
002485  002689  // Notes : Appends a copy of the source string to the destination string.
002486  002690  //       : The number of characters copied is limited by "count".
002487  002691  //       : The terminating null character in destination is overwritten by
002488  002692  //       : the first character of source, and a new null-character is appended
002489  002693  //       : at the end of the new string formed by the concatenation of both in destination.
002490  002694  //       : returns destination.
002491  002695        
002492  002696        
002493  002697  func sys_StoreTouchCalibration(), 1;
002494  002698  // Syntax: sys_StoreTouchCalibration();
002495  002699  // Usage : r := sys_StoreTouchCalibration();
002496  002700  // Notes : Store the touch calibration values in non-volatile memory.
002497  002701  //       : Returns true if the values have been accepted and stored,
002498  002702  //       : else returns false if write could not be performed, or
002499  002703  //       : touch calibration values are improbable.
002500  002704  //       : The values that are stored are obtained from:-
002501  002705  //     : TOUCH_XMINCAL             78  // touch calibration value
002502  002706  //     : TOUCH_YMINCAL             79  // touch calibration value
002503  002707  //       : TOUCH_XMAXCAL             80  // touch calibration value
002504  002708  //       : TOUCH_YMAXCAL             81  // touch calibration value
002505  002709  //       : refer to the 4DGL example touchCalibrate.4DG for further information.
002506  002710  //       : This function is not supported on uVGA, Capicitive touch
002507  002711  //       : and 4.3" resistive touch modules.
002508  002712        
002509  002713        
002510  002714  func unicode_page("charbeg","charend","charoffset"), 1;
002511  002715  // Syntax: unicode_page("charbeg","charend","charoffset");
002512  002716  // Usage : eg:  F_Traditional_0x20_0xFF
002513  002717  // Notes : After selecting a unicode image control with txt_FontID,
002514  002718  //       : this function is called to set the required font within the
002515  002719  //       : unicode set. The file "Unicode.inc" contains wrappers for
002516  002720  //       : this function, and it is not normally called directly.
002517  002721  //       : Returns count of characters in the set.
002518  002722  //       : Refer to "Unicode.inc" for further information.
002519  002723        
002520  002724        
002521  002725  func EVE_SP(), 1;
002522  002726  // Syntax: EVE_SP();
002523  002727  // Usage : eg:  print(EVE_SP());
002524  002728  // Notes : Used for debugging to assess the current stack level,
002525  002729  //       : mainly for checking stack leaks
002526  002730        
002527  002731  func EVE_SSIZE(), 1;
002528  002732  // Syntax: EVE_SSIZE();
002529  002733  // Usage : eg:  print(EVE_SSIZE());
002530  002734  // Notes : Used to get the stack size,
002531  002735  //       : mainly for debugging purposes
002532  002736        
002533  002737        
002534  002738  // uVGAII extended functions
002535  002739  func disp_Sync("line"), 0;                      //  (uVGA only)  wait till scanline reaches "line"
002536  002740  // Syntax: disp_Sync(line);
002537  002741  // Usage : disp_Sync(480);
002538  002742  // Notes : Waits till the hardware gets to a certain line.
002539  002743  //       : Allows the program to synchronise writing to the hardware for flicker free operation.
002540  002744  //       : Some experimentation may be needed to find an optimum line for disp_Sync
002541  002745  //       : depending on the graphics operation. The higher the value, the slower
002542  002746  //       : the throughput. A cetain point will be reached (number of scanlines + blanking lines
002543  002747  //       : within the vertical retrace period) where it will just 'hang up' stopping the
002544  002748  //       : entire process. Eg, in 640x480 mode, if the 'lines' value is 507, operation will
002545  002749  //       : be slowest (as its actually right at the end of the blanking period) and 508
002546  002750  //       : will cause a hangup situation as it is above the highes scanline value.
002547  002751  //       : Currently, this function is only supported on displays with SSD1963 driver.
002548  002752        
002549  002753        
002550  002754  // New functions added to PmmC v2.8
002551  002755  //================================================================
002552  002756  func CY(), 1;
002553  002757  // Syntax: CY();
002554  002758  // Usage : myvar := 0xFFF8 + 9;                 // result = 1
002555  002759  //       : print(myvar," "CY(),"\n");           // carry = 1
002556  002760  // Notes : This function returns the carry status of an
002557  002761  // unsigned overflow from any 16 or 32bit additions or sutractions.
002558  002762  //================================================================
002559  002763        
002560  002764        
002561  002765  //================================================================
002562  002766  func str_ByteMove("src", "dest", "count"), 1;
002563  002767  // func str_ByteMove("src", "dest", "count"), 1;
002564  002768  // Syntax   : str_ByteMove(src, dest, bytecount);
002565  002769  // Input    : STR *source points to byte aligned source.
002566  002770  //          : STR *dest   points to byte aligned destination.
002567  002771  //          : VAR count   number of bytes to transfer.
002568  002772  // Usage    : nextpos := str_ByteMove(s, d, 100);
002569  002773  // Notes    : copy bytes from "src" to "dest", stopping only
002570  002774  //          : when "count" is exhausted.
002571  002775  //          : No terminator is appended, it is purely a
002572  002776  //          : byte copy, and any zeroes encountered will
002573  002777  //          : also be copied.
002574  002778  // Returns  : returns a pointer to the end of the destination
002575  002779  //          : (which is "dest" + "count")
002576  002780  //================================================================
002577  002781        
002578  002782        
002579  002783  //================================================================
002580  002784  func str_Copy("dest", "src"), 1;
002581  002785  // Syntax   : str_Copy(dest, src);
002582  002786  // Input    : STR *dest   points to byte aligned destination.
002583  002787  //          : STR *source points to byte aligned source.
002584  002788  // Usage    : nextplace := str_Copy(d, s);
002585  002789  // Notes    : copy a string from "src" to "dest", stopping only
002586  002790  //          : when the end of source string "src" is encountered
002587  002791  //          : (0x00 terminator).
002588  002792  //          : The terminator is always appended, even if "src" is
002589  002793  //          : an empty string.
002590  002794  // Returns  : returns a pointer to the 0x00 string terminator at
002591  002795  //          : end of "dest" (which is "dest" + str_Length(src); )
002592  002796  //================================================================
002593  002797        
002594  002798  //================================================================
002595  002799  func str_CopyN("dest", "src", "count"), 1;
002596  002800  // Syntax   : str_CopyN(dest, src, bytecount);
002597  002801  // Input    : STR *dest   points to byte aligned destination.
002598  002802  //          : STR *source points to byte aligned source.
002599  002803  //          : VAR count   max number of chars to copy.
002600  002804  // Usage    : nextplace := str_CopyN(d, s, 100);
002601  002805  // Notes    : copy a string from "src" to "dest", stopping only
002602  002806  //          : when "count" is exhausted, or end of source
002603  002807  //          : string "str" is encountered (0x00 string terminator).
002604  002808  //          : The terminator is always appended, even if
002605  002809  //          : "count" is zero, or "src" is a null string.
002606  002810  // Returns  : returns a pointer to the 0x00 string terminator
002607  002811  //          : (which is "dest" + whatever was copied)
002608  002812  //================================================================
002609  002813        
002610  002814  //================================================================
002611  002815  func umul_1616("&res32", "val1", "val2"), 1;
002612  002816  // Syntax   : umul_1616(&res32, varA, varB);
002613  002817  // Input    : DWORD *result   points to 32bit result register.
002614  002818  //          : VAR   val1  16bit register or constant
002615  002819  //          : VAR   val2  16bit register or constant
002616  002820  // Usage    : var res32[2];
002617  002821  //          : umul_1616(&res32, myvar, 50000);
002618  002822  // Notes    : performs an unsigned multiply of 2 x 16bit values
002619  002823  //          : placing the 32bit result in a 2 word array.
002620  002824  // Returns  : the pointer to the 32bit result.
002621  002825  //          : carry and overflow are not affected.
002622  002826  //================================================================
002623  002827        
002624  002828  //================================================================
002625  002829  func uadd_3232("&res32", "&val1", "&val2"), 1;
002626  002830  // Syntax   : cmp_3232(&res32, &varA, &varB);
002627  002831  // Input    : DWORD *res32 points to optional result (or zero for compare)
002628  002832  //          : DWORD *val1 points to 32bit augend
002629  002833  //          : DWORD *val2 points to 32bit addend
002630  002834  // Usage    : var res32[2];
002631  002835  //          : res := cmp_3232(res32, val1, val2);
002632  002836  // Notes    : performs an unsigned addition of 2 x 32bit values
002633  002837  //          : placing the 32bit result in a 2 word array.
002634  002838  // Returns  : returns 1 on 32bit unsigned overflow (carry).
002635  002839  //          ; carry flag is also set on 32bit unsigned overflow
002636  002840  //          ; and can be read with the CY() function.
002637  002841  //================================================================
002638  002842        
002639  002843  //================================================================
002640  002844  func usub_3232("&res32", "&val1", "&val2"), 1;
002641  002845  // Syntax   : cmp_3232(&res32, &varA, &varB);
002642  002846  // Input    : DWORD *res32 points to optional result (or zero for compare)
002643  002847  //          : DWORD *val1 points to first 32bit minuend
002644  002848  //          : DWORD *val2 points to 32bit subtrahend
002645  002849  // Usage    : var res32[2];
002646  002850  //          : res := cmp_3232(res32, val1, val2);
002647  002851  // Notes    : performs an unsigned subtraction of 2 x 32bit values
002648  002852  //          : placing the 32bit result in a 2 word array.
002649  002853  // Returns  : returns 1 on 32bit unsigned overflow (borrow).
002650  002854  //          ; carry flag is also set on 32bit unsigned underflow
002651  002855  //          ; and can be read with the CY() function.
002652  002856  //================================================================
002653  002857        
002654  002858  //================================================================
002655  002859  func ucmp_3232("&val1", "&val2"), 1;
002656  002860  // Syntax   : cmp_3232(&varA, &varB);
002657  002861  // Input    : DWORD *val1 points to 32bit minuend
002658  002862  //          : DWORD *val2 points to 32bit sutrahend
002659  002863  // Usage    : res := cmp_3232(val1, val2);
002660  002864  // Notes    : performs an unsigned comparison of 2 x 32bit values.
002661  002865  //          : The result of the subtraction is returned.
002662  002866  // Returns  : 0  if equal
002663  002867  //          : 1  if val1 > val2
002664  002868  //          : -1 if val1 < val2
002665  002869  //          : This function does not affect the carry flag.
002666  002870  //================================================================
002667  002871        
002668  002872  //------------------------------------------------------------------//
002669  002873  // CONSTANTS
002670  002874  //------------------------------------------------------------------//
002671  002875        
002672  002876  // generic constants
002673  002877  #CONST
002674  002886  #END
002675  002887        
002676  002888  //------------------------------------------------------------------------------
002677  002889  // Pin related constants
002678  002890  //------------------------------------------------------------------------------
002679  002891  #CONST
002680  002909  #END
002681  002910        
002682  002911  //------------------------------------------------------------------------------
002683  002912  //gfx_Set() related constants
002684  002913  //------------------------------------------------------------------------------
002685  002914  #CONST
002686  002931  #END
002687  002932        
002688  002933        
002689  002934  //gfx_Get() related constants
002690  002935  #CONST
002691  002944  #END
002692  002945        
002693  002946        
002694  002947        
002695  002948        
002696  002949  #CONST
002697  002962  #END
002698  002963        
002699  002964        
002700  002965  #CONST
002701  002988  #END
002702  002989        
002703  002990  //------------------------------------------------------------------------------
002704  002991  //txt_Set() related constants
002705  002992  //------------------------------------------------------------------------------
002706  002993  #CONST
002707  003012  #END
002708  003013        
002709  003014        
002710  003015        
002711  003016  //------------------------------------------------------------------------------
002712  003017  //txt_Set() related arguments
002713  003018  // NB:- FONT4 must be inherited if required,
002714  003019  // eg #inherit "FONT4.fnt"
002715  003020  //------------------------------------------------------------------------------
002716  003021  #CONST
002717  003033  #END
002718  003034        
002719  003035        
002720  003036        
002721  003037  //touch_Set() related constants
002722  003038  #CONST
002723  003042  #END
002724  003043        
002725  003044  //touch_Get() related constants
002726  003045  #CONST
002727  003053  #END
002728  003054        
002729  003055  // image control offset related constants
002730  003056  #CONST
002731  003063  #END
002732  003064        
002733  003065  // image attribute flags
002734  003066  // for img_SetAttributes(...) and img_ClearAttributes(...)
002735  003067  #CONST
002736  003081  #END
002737  003082        
002738  003083        
002739  003084  #constant ALL 0xFFFF // argument for img_xxx functions to update all images
002740  003084  #constant ALL 0xFFFF // argument for img_xxx functions to update all images
002741  003085        
002742  003086  // image control entry offsets
002743  003087  #CONST
002744  003102  #END
002745  003103        
002746  003104  #CONST
002747  003122  #END
002748  003123        
002749  003124        
002750  003125        
002751  003126        
002752  003127  #CONST
002753  003147  #END
002754  003148        
002755  003149        
002756  003150        
002757  003151  // timer control  related constants
002758  003152  #CONST
002759  003161  #END
002760  003162        
002761  003163  // I2C timing related constants
002762  003164  #CONST
002763  003168  #END
002764  003169        
002765  003170        
002766  003171  // spi_Init(...)  mode arguments
002767  003172  #CONST
002768  003182  #END
002769  003183        
002770  003184  //------------------------------------------------------------------------------
002771  003185  // system WORD variables accesible with peekW and pokeW or pointer access
002772  003186  // Note that the txt_Set variables (0-15) and gfx_set variables (16-31)
002773  003187  // can also be accessed with peekW and pokeW
002774  003188  //------------------------------------------------------------------------------
002775  003189        
002776  003190  #CONST
002777  003282  #END
002778  003283        
002779  003284  //------------------------------------------------------------------------------
002780  003285  // FILEIO Error Code Constants
002781  003286  //------------------------------------------------------------------------------
002782  003287  #CONST
002783  003312  #END
002784  003313        
002785  003314  //==================================================================================================
002786  003315        
002787  003316        
002788  003317        
002789  000013      #ENDIF
002790  000014        
002791  000015        
002792  000016         #CONST
002793  000102      #END
002794  000103        
002795  000104  #constant TOUCH_DRIVE 78      // external pointing device control for gfx_Set(TOUCH_DRIVE, command);
002796  000104  #constant TOUCH_DRIVE 78      // external pointing device control for gfx_Set(TOUCH_DRIVE, command);
002797  000105        
002798  000106        
002799  000107        
002800  000108        
002801  000109        
002802  000110  //===========================================================================================
002803  000111        
002804  000112        
002805  000002  // Cameron Horvath (Jan. 15, 2013)
002806  000003        
file C:\Program Files (x86)\4D Labs\4D Workshop 4 IDE\include\4DGL_16bitColours.fnc

002807  000004  #inherit "4DGL_16bitColours.fnc"
002808  000004  #inherit "4DGL_16bitColours.fnc"
002809  000004  */
002810  000005        
002811  000006        
002812  000007        
002813  000008  #CONST
002814  000149  #END
002815  000150        
file C:\Program Files (x86)\4D Labs\4D Workshop 4 IDE\include\VisualConst.inc

002816  000005  #inherit "VisualConst.inc"
002817  000005  #inherit "VisualConst.inc"
002818  000001  // Line Patterns
002819  000002  #constant  LPCOARSE    0xF0F0
002820  000002  #constant  LPCOARSE    0xF0F0
002821  000003  #constant  LPMEDIUM    0x3333
002822  000003  #constant  LPMEDIUM    0x3333
002823  000004  #constant  LPFINE      0xAAAA
002824  000004  #constant  LPFINE      0xAAAA
002825  000005  #constant  LPDASHDOT   0x03CF
002826  000005  #constant  LPDASHDOT   0x03CF
002827  000006  #constant  LPDASHDOTDOT 0x0333
002828  000006  #constant  LPDASHDOTDOT 0x0333
002829  000007  #constant  LPSOLID     0x0000
002830  000007  #constant  LPSOLID     0x0000
file C:\Users\Mikester\Documents\GitHub\LCD-Display\EcoCarMain.4DWork\EcoCarMainConst.inc

002831  000006  #inherit "EcoCarMainConst.inc"
002832  000006  #inherit "EcoCarMainConst.inc"
002833  000001  // File generated 2013-10-15 1:49:04 PM
002834  000002  // Warning! This is a generated file, any manual changes will be
002835  000003  // lost during the next generation.
002836  000004        
002837  000005  // object indexes into ImageControl
002838  000006  #CONST
002839  000068  #END
002840  000069        
002841  000070  var disk, hndl ;
file C:\Program Files (x86)\4D Labs\4D Workshop 4 IDE\include\ledDigitsDisplay.inc

002842  000007  #inherit "ledDigitsDisplay.inc"
002843  000007  #inherit "ledDigitsDisplay.inc"
002844  000001  // WARNING, this code will crash if newval exceeds maximum displayable number
002845  000002  func ledDigitsDisplay(var newval, var index, var left, var Digits, var MinDigits, var WidthDigit, var LeadingBlanks)
002846  000003      var i, k, l, lb ;
002847  000004      l := 1 ;
002848  000005      for (i := 1; i < Digits; i++)
002849  000006          l *= 10 ;
002850  000007      next
002851  000008      lb := LeadingBlanks ;
002852  000009      for (i := 0; i < Digits; i++)
002853  000010          k := newval / l ;
002854  000011          newval -= k * l ;
002855  000012          if ( lb && (i < Digits - MinDigits) )
002856  000013              if (k == 0)
002857  000014                  k := -1 ; // was 10
002858  000015              else
002859  000016                  lb := 0 ;
002860  000017              endif
002861  000018          endif
002862  000019          l /= 10 ;
002863  000020          img_SetWord(hndl, index, IMAGE_INDEX, k);
002864  000021          img_SetWord(hndl, index, IMAGE_XPOS, left+i*WidthDigit) ;
002865  000022          img_Show(hndl, index);
002866  000023      next
002867  000024  endfunc
002868  000025        
002869  000008        
002870  000009  var combuf[3];
002871  000010  var tmpbuf[3];
002872  000011  var n, ch;
002873  000012        
002874  000013        
002875  000014  #CONST
002876  000018  #END
002877  000019        
002878  000020  var cycle := 0; // Indicates save cycles for odometer. Don't want to save on the uSD card too quickly.
002879  000021  var activeForm := 1;    // Indicates which form we currently have active.
002880  000022        
002881  000023  // Form1 Quantities:
002882  000024  var speed := 0;
002883  000025  var trip := 0;   // Low-precision (displayed) values.
002884  000026  var odo := 0;
002885  000027  var odo_micro := 0; // High-precision values used in distance calcs.
002886  000028  var trip_micro := 0;
002887  000029  var cruise := 0;//0xFFFF;
002888  000030  var direction := 0;//0x0000;
002889  000031        
002890  000032  // Form2 Quantities:
002891  000033  var temp_outside := 0;//40;
002892  000034  var temp_cabin := 0;//20 + 30;
002893  000035  var temp_trunk := 0;//20 + 30;
002894  000036  var temp_fuelcell := 0;//0x6A;
002895  000037        
002896  000038  // Form3 Quantities:
002897  000039  var vstack := 0;//0x74;
002898  000040  var vaccessory := 0;//121;
002899  000041  var bbvoltage := 0;//482;
002900  000042  var istack := 0;//0x0044;
002901  000043  var motcurr1 := 0;//0x00;
002902  000044  var motcurr2 := 0;//0x00;
002903  000045  var pwrFuelCell := 0;//0xFFFF;
002904  000046  var pwrMotor := 0;
002905  000047  var backupVal := 0;
002906  000048        
002907  000049  // Form4 Quantities:
002908  000050  var ptank := 0;//0x07EE;
002909  000051        
002910  000052  var lastTimeout := 0;
002911  000053        
002912  000054  func reset_trip()
002913  000055      // Reset trip odometer.
002914  000056      trip_micro := 0;
002915  000057      trip := 0;
002916  000058        
002917  000059      // Redraw trip timer.
002918  000060      img_Show(hndl, idig_trip);
002919  000061      if(activeForm == 1)
002920  000062          ledDigitsDisplay(trip, idig_trip+1, 344, 4, 2, 16, 0) ;
002921  000063      endif
002922  000064      var hFile;
002923  000065      // Clear odometer file on uSD
002924  000066      if(file_Exists("TRIP.TXT"))
002925  000067          file_Erase("TRIP.TXT");   // Get rid of the old data.
002926  000068      endif
002927  000069        
002928  000070  endfunc
002929  000071        
002930  000072  func update_odo()
002931  000073          var time_elapsed, inc;
002932  000074          time_elapsed := peekW(SYSTEM_TIMER_LO); // Read from system timer.
002933  000075          inc := time_elapsed/10*speed/36;
002934  000076          //txt_MoveCursor(1,1);
002935  000077          //print("inc: ", [DEC] inc,"             \n");
002936  000078        
002937  000079          // odo contains data to nearest kilometre.
002938  000080          // odo_micro has sub-kilometre data (accurate to nearest 10 cm)
002939  000081          if(inc > 0)
002940  000082              odo_micro := odo_micro + inc;
002941  000083              trip_micro := trip_micro + inc;
002942  000084          endif
002943  000085        
002944  000086          odo := odo + odo_micro / 10000; // If there's an extra kilometer, throw it onto odo.
002945  000087          trip := trip + trip_micro / 1000; // If there's an extra 1/10th of kilometer, throw it onto odo.
002946  000088        
002947  000089          if(odo_micro > 10000)
002948  000090              if(activeForm == 1)
002949  000091                  ledDigitsDisplay(odo, idig_odo+1, 72, 4, 1, 16, 0) ;
002950  000092              endif
002951  000093        
002952  000094              // Save odometer data to uSD
002953  000095              var hFile;
002954  000096              if(file_Exists("ODO.TXT"))
002955  000097                  file_Erase("ODO.TXT");   // Get rid of the old data.
002956  000098              endif
002957  000099        
002958  000100              if(hFile := file_Open("ODO.TXT" ,'w'))
002959  000101                  file_PutW(odo, hFile);   // Write the new odometer data to uSD.
002960  000102                  file_Close(hFile);
002961  000103              endif
002962  000104          endif
002963  000105        
002964  000106          if(trip_micro > 1000)
002965  000107              if(activeForm == 1)
002966  000108                  ledDigitsDisplay(trip, idig_trip+1, 344, 4, 2, 16, 0) ;
002967  000109              endif
002968  000110        
002969  000111              // Save odometer data to uSD
002970  000112              if(file_Exists("TRIP.TXT"))
002971  000113                  file_Erase("TRIP.TXT");   // Get rid of the old data.
002972  000114              endif
002973  000115        
002974  000116              if(hFile := file_Open("TRIP.TXT" ,'w'))
002975  000117                  file_PutW(trip, hFile);   // Write the new odometer data to uSD.
002976  000118                  file_Close(hFile);
002977  000119              endif
002978  000120          endif
002979  000121        
002980  000122          odo_micro := odo_micro % 10000;       // Take the remainder and keep it in odo_micro
002981  000123          trip_micro := trip_micro % 1000;       // Take the remainder and keep it in trip_micro
002982  000124          cycle++;
002983  000125          if((cycle % 10 == 0) && inc > 0)
002984  000126              if(file_Exists("ODOM.TXT"))
002985  000127                  file_Erase("ODOM.TXT");   // Get rid of the old data.
002986  000128              endif
002987  000129        
002988  000130              if(hFile := file_Open("ODOM.TXT" ,'w'))
002989  000131                  file_PutW(odo_micro, hFile);   // Write the new odometer data to uSD.
002990  000132                  file_Close(hFile);
002991  000133              endif
002992  000134              cycle := 0;
002993  000135          endif
002994  000136        
002995  000137          // Save new speed data.
002996  000138          sys_SetTimer(TIMER1, 1000);
002997  000139          pokeW(SYSTEM_TIMER_LO, 0);  // Reset speed timer.
002998  000140        
002999  000141      endfunc
003000  000142        
003001  000143        
003002  000144        
003003  000145  func process_serial_data(var type, var databyte1, var databyte2)
003004  000146      var dataword := 0;
003005  000147      dataword := databyte1<<8 | (databyte2 & 0x00FF);
003006  000148      // Process the data received on the serial port.
003007  000149        
003008  000150      if(type == 0xA0)
003009  000151          if(activeForm == 3 && pwrFuelCell != databyte2)
003010  000152              img_SetWord(hndl, iledFuelCellPwr, IMAGE_INDEX, databyte2 && 0x01) ;      // where numx is 0 (Off) or 1 (On)
003011  000153              img_Show(hndl,iledFuelCellPwr) ;
003012  000154          endif
003013  000155          pwrFuelCell := databyte2;
003014  000156      else if(type == 0xA1)
003015  000157          // Fuel cell temperature
003016  000158          if(activeForm == 2 && temp_fuelcell != databyte2)
003017  000159              // Top end is 70 deg. C
003018  000160              img_SetWord(hndl, itemp_fuelcell, IMAGE_INDEX, databyte2/2);
003019  000161              img_Show(hndl, itemp_fuelcell);
003020  000162          endif
003021  000163        
003022  000164          temp_fuelcell := databyte2;
003023  000165      else if(type == 0xA2)
003024  000166          // Not being displayed.
003025  000167      else if(type == 0xA3)
003026  000168          // Fuel cell current (top end 20A)
003027  000169         if(activeForm == 3 && istack != databyte2)
003028  000170              ledDigitsDisplay(databyte2*2, idigStackI+1, 160, 3, 2, 16, 0) ;
003029  000171              img_SetWord(hndl, ibarStackI, IMAGE_INDEX, databyte2*2/5) ;
003030  000172              img_Show(hndl, ibarStackI) ;
003031  000173          endif
003032  000174        
003033  000175          if(istack > 0x00 && databyte2 == 0x00 && speed >= 7)
003034  000176              dispErrorMsg(5, 0xD1, 1); // Fuel cell abrupt shutoff.
003035  000177          endif
003036  000178        
003037  000179          istack := databyte2;
003038  000180      else if(type == 0xA4)
003039  000181          if(activeForm == 3 && vstack != databyte2)
003040  000182              ledDigitsDisplay(databyte2*10/3, idigStackV+1, 160, 3, 2, 16, 0) ;
003041  000183              img_SetWord(hndl, ibarStackV, IMAGE_INDEX, databyte2*2/3) ;
003042  000184              img_Show(hndl, ibarStackV) ;
003043  000185          endif
003044  000186          vstack := databyte2;
003045  000187      else if(type == 0xB0)
003046  000188          // Buck-boost voltage
003047  000189          if(activeForm == 3 && bbvoltage != dataword)
003048  000190              ledDigitsDisplay(dataword/10, idigBuckBoostV+1, 160, 3, 2, 16, 0);
003049  000191              img_SetWord(hndl, ibarBuckBoostV, IMAGE_INDEX, dataword/6) ;
003050  000192              img_Show(hndl, ibarBuckBoostV) ;
003051  000193          endif
003052  000194          bbvoltage := dataword;
003053  000195      else if(type == 0xB1)
003054  000196          // Motor pwr LED
003055  000197          if(activeForm == 3 && pwrMotor != databyte2)
003056  000198              img_SetWord(hndl, iledMotorPwr, IMAGE_INDEX, databyte2 && 0x01) ;      // where numx is 0 (Off) or 1 (On)
003057  000199              img_Show(hndl,iledMotorPwr) ;
003058  000200          endif
003059  000201          pwrMotor := databyte2;
003060  000202       else if(type == 0xB2)
003061  000203          // Motor current 1
003062  000204          if(activeForm == 3 && motcurr1 != dataword)
003063  000205              ledDigitsDisplay(dataword/10, idigMotCurr1+1, 160, 3, 2, 16, 0);
003064  000206              img_SetWord(hndl, ibarMotCurr1, IMAGE_INDEX, dataword*2) ;
003065  000207              img_Show(hndl, ibarMotCurr1) ;
003066  000208          endif
003067  000209          motcurr1 := dataword;
003068  000210       else if(type == 0xB3)
003069  000211          // Motor current 2
003070  000212          if(activeForm == 3 && motcurr2 != dataword)
003071  000213              ledDigitsDisplay(dataword/10, idigMotCurr2+1, 160, 3, 2, 16, 0);
003072  000214              img_SetWord(hndl, ibarMotCurr2, IMAGE_INDEX, dataword*2) ;
003073  000215              img_Show(hndl, ibarMotCurr2) ;
003074  000216          endif
003075  000217          motcurr2 := dataword;
003076  000218      else if(type == 0xB4)
003077  000219          // Speed data:
003078  000220          if(databyte2 != speed)
003079  000221              speed := databyte2;
003080  000222              if(activeForm == 1)
003081  000223                  // Redraw the speed and the bar on the main form.
003082  000224                  ledDigitsDisplay2(speed, idig_speed+1, 76, 2, 1, 100, 1, 1) ;
003083  000225        
003084  000226                  img_SetWord(hndl, igauge_speed, IMAGE_INDEX, speed*100/60) ; // where frame is 0 to 100 (for a displayed 0 to 100)
003085  000227                  img_Show(hndl,igauge_speed) ;
003086  000228        
003087  000229              endif
003088  000230          endif
003089  000231       else if(type == 0xB5)
003090  000232          // Direction
003091  000233          if(activeForm == 1 && direction != databyte2)
003092  000234              if(databyte2 & 0x01 == 0x01)
003093  000235                  gfx_RectangleFilled(8, 40, 61, 150, 0x0000) ;
003094  000236                  img_Show(hndl,iImage6) ;
003095  000237              else
003096  000238                  gfx_RectangleFilled(8, 40, 61, 150, 0x0000) ;
003097  000239                  img_Show(hndl,iImage5);
003098  000240              endif
003099  000241          endif
003100  000242          direction := databyte2;
003101  000243       else if(type == 0xB6)
003102  000244          // Cruise control
003103  000245          if(activeForm == 1 && cruise != databyte2)
003104  000246              if(databyte2 & 0x01 == 0x01)
003105  000247                  img_Enable(hndl,iImage7) ;
003106  000248                  img_Show(hndl,iImage7) ;
003107  000249              else
003108  000250                  img_Disable(hndl,iImage7) ;
003109  000251                  gfx_RectangleFilled(6, 151, 59, 201, BLACK) ;
003110  000252              endif
003111  000253          endif
003112  000254          cruise := databyte2;
003113  000255       else if(type == 0xC0)
003114  000256          // Trunk temperature
003115  000257          if(activeForm == 2 && temp_trunk != databyte2)
003116  000258              img_SetWord(hndl, itemp_trunk, IMAGE_INDEX, databyte2);
003117  000259              img_Show(hndl, itemp_trunk);
003118  000260          endif
003119  000261          temp_trunk := databyte2;
003120  000262       else if(type == 0xC1)
003121  000263          // Cabin temperature
003122  000264          if(activeForm == 2 && temp_cabin != databyte2)
003123  000265              img_SetWord(hndl, itemp_cabin, IMAGE_INDEX, databyte2);
003124  000266              img_Show(hndl, itemp_cabin);
003125  000267          endif
003126  000268          temp_cabin := databyte2;
003127  000269       else if(type == 0xC2)
003128  000270          // Outside temperature
003129  000271          if(activeForm == 2 && temp_outside != databyte2)
003130  000272              img_SetWord(hndl, itemp_outside, IMAGE_INDEX, databyte2/2 + 30);
003131  000273              img_Show(hndl, itemp_outside);
003132  000274          endif
003133  000275          temp_outside := databyte2;
003134  000276       else if(type == 0xC3)
003135  000277           //print([HEX] dataword);
003136  000278          // accessory battery voltage
003137  000279          if(activeForm == 3 && vaccessory != dataword)
003138  000280        
003139  000281              ledDigitsDisplay(dataword, idigAccV+1, 160, 3, 2, 16, 0) ;
003140  000282              img_SetWord(hndl, ibarAccV, IMAGE_INDEX, dataword*2/3) ;
003141  000283              img_Show(hndl, ibarAccV) ;
003142  000284          endif
003143  000285          vaccessory := dataword;
003144  000286       else if(type == 0xC4)
003145  000287          // backup alarm
003146  000288          if(0)//backupVal != dataword)
003147  000289              backupVal := dataword;
003148  000290              if(backupVal >= 325)
003149  000291                  sys_SetTimer(TIMER2, 0);
003150  000292              else
003151  000293                  sys_SetTimer(TIMER2, 1);
003152  000294              endif
003153  000295          endif
003154  000296      else if(type == 0xF0)
003155  000297          //if(databyte2 != lastTimeout)
003156  000298          //    dispErrorMsg(databyte1, databyte2, 0);
003157  000299          //endif
003158  000300          lastTimeout := databyte2;
003159  000301      endif
003160  000302        
003161  000303  endfunc
003162  000304        
003163  000305  func setBackupAlarm()
003164  000306  if(activeForm != 1)
003165  000307  draw_form1();
003166  000308  else
003167  000309  clearErrors();
003168  000310  endif
003169  000311      snd_Volume(127);
003170  000312      if(direction == 0xFF)
003171  000313          if(backupVal < 325)
003172  000314                   txt_Set(TEXT_COLOUR, RED);
003173  000315                txt_MoveCursor(20,6);
003174  000316                  print("WARNING: Obstruction behind vehicle!");
003175  000317                   txt_MoveCursor(21,6);
003176  000318                   print("Check clearance before backing up.");
003177  000319          endif
003178  000320          // We are going in reverse. Detect our distance.
003179  000321          if(backupVal < 72) // 0.3m
003180  000322              if(!snd_Playing())
003181  000323                  file_PlayWAV("backup3.wav");
003182  000324              endif
003183  000325              sys_SetTimer(TIMER2, 200);
003184  000326          else if(backupVal < 250) // 1.3m
003185  000327              if(!snd_Playing())
003186  000328                  file_PlayWAV("backup2.wav");
003187  000329              endif
003188  000330              sys_SetTimer(TIMER2, 200);
003189  000331          else if(backupVal < 325) // 1.3m
003190  000332              if(!snd_Playing())
003191  000333                  file_PlayWAV("backup1.wav");
003192  000334              endif
003193  000335              sys_SetTimer(TIMER2, 200);
003194  000336          else if(backupVal >= 325)
003195  000337               sys_SetTimer(TIMER2, 0);
003196  000338          endif
003197  000339        
003198  000340        
003199  000341        
003200  000342      endif
003201  000343        
003202  000344  endfunc
003203  000345        
003204  000346  func dispErrorMsg(var databyte1, var databyte2, var alarm)
003205  000347  if(activeForm != 1)
003206  000348  draw_form1();
003207  000349  else
003208  000350  clearErrors();
003209  000351  endif
003210  000352          txt_MoveCursor(20,6);
003211  000353          txt_Set(TEXT_COLOUR, RED);
003212  000354              if(activeForm == 1 && databyte2 != lastTimeout && databyte1 == 2)
003213  000355                  // Fuel cell slave not responding.
003214  000356                   print("ERROR: Comm timeout with FCell sensor board! (", [HEX] databyte2, ")");
003215  000357                   txt_MoveCursor(21,6);
003216  000358                   print("Please check connections and reset system.");
003217  000359              else if(activeForm == 1 && activeForm == 1 && databyte2 != lastTimeout && databyte1 == 1)
003218  000360                  // Fuel cell slave not responding.
003219  000361        
003220  000362                   print("ERROR: Comm timeout with master node! (", [HEX] databyte2, ")");
003221  000363                   txt_MoveCursor(21,6);
003222  000364                   print("Please check connections and code timing.");
003223  000365              else if(activeForm == 1 && databyte2 != lastTimeout && databyte1 == 3)
003224  000366                   // Motors slave not responding.
003225  000367        
003226  000368                   print("ERROR: Comm timeout with Motor sensor board! (", [HEX] databyte2, ")");
003227  000369                   txt_MoveCursor(21,6);
003228  000370                   print("Please check connections and reset system.");
003229  000371              else if(activeForm == 1 && databyte2 != lastTimeout && databyte1 == 4)
003230  000372                   // Misc. slave not responding.
003231  000373        
003232  000374                   print("ERROR: Comm timeout with Misc. sensor board! (", [HEX] databyte2, ")");
003233  000375                   txt_MoveCursor(21,6);
003234  000376                   print("Please check connections and reset system.");
003235  000377              else if(activeForm == 1 && databyte2 != lastTimeout && databyte1 == 5)
003236  000378                  // We're saving "5" as a special case of error.
003237  000379                  if(databyte2 == 0xD1)
003238  000380                      // Fuel cell abruptly died.
003239  000381                   print("WARNING: Fuel cell shutoff detected!");
003240  000382                   txt_MoveCursor(21,6);
003241  000383                   print("Release accelerator and cruise as far as you can?");
003242  000384                  endif
003243  000385        
003244  000386              endif
003245  000387              if(alarm)
003246  000388                  play_alarm();
003247  000389              endif
003248  000390  endfunc
003249  000391        
003250  000392  func clearErrors()
003251  000393      txt_MoveCursor(20,6);
003252  000394      print("                                                   ");
003253  000395      txt_MoveCursor(21,6);
003254  000396      print("                                                 ");
003255  000397        
003256  000398      if(lastTimeout > 0xD0)
003257  000399      lastTimeout := 0x00; // Clear any critical errors so they can come up again.
003258  000400      endif
003259  000401        
003260  000402  endfunc
003261  000403        
003262  000404  func serial_read()
003263  000405  start_serial:
003264  000406      com_Init(combuf, 3, 0xFF );
003265  000407      pin_HI(PIN_LCDOUT); // Signal to PIC that we are listening
003266  000408        
003267  000409      setbaud(BAUD_57600);
003268  000410        
003269  000411      repeat
003270  000412      until(com_Full());
003271  000413        
003272  000414      n := com_Count();
003273  000415      while(n--)
003274  000416          if( (ch := serin()) < -1)
003275  000417              print([DEC] ch);
003276  000418              com_Reset();
003277  000419              goto start_serial;
003278  000420          else if(ch == -1)
003279  000421               print([DEC] ch);
003280  000422          endif
003281  000423          tmpbuf[2-n] := ch;
003282  000424      wend
003283  000425        
003284  000426      pin_LO(PIN_LCDOUT); // No longer listening.
003285  000427        
003286  000428        
003287  000429      com_Reset();
003288  000430        
003289  000431      // Process data.
003290  000432      process_serial_data(tmpbuf[0], tmpbuf[1], tmpbuf[2]);
003291  000433        
003292  000434      // Check for touch events.
003293  000435      checkTouchEvents();
003294  000436        
003295  000437      // Check the status of the PIC pin. Either keep listening, or
003296  000438      // draw the form and return back to the main routine.
003297  000439        
003298  000440      if (pin_Read(PIN_PICIN))
003299  000441          //goto start_serial;
003300  000442      endif
003301  000443        
003302  000444  endfunc
003303  000445        
003304  000446  func draw_form4()
003305  000447      gfx_Cls();
003306  000448        
003307  000449        
003308  000450      // Form4 1.0 generated 2/8/2013 11:11:51 PM
003309  000451        
003310  000452      // Statictext20 1.0 generated 2/8/2013 11:11:51 PM
003311  000453      img_Show(hndl,iStatictext20) ;
003312  000454        
003313  000455      // Angularmeter1 1.0 generated 2/8/2013 11:11:51 PM
003314  000456      img_SetWord(hndl, iAngularmeter1, IMAGE_INDEX, ptank) ; // where frame is 0 to 2200 (for a displayed 0 to 2200)
003315  000457      img_Show(hndl,iAngularmeter1) ;
003316  000458        
003317  000459      // Statictext21 1.0 generated 2/8/2013 11:11:51 PM
003318  000460      img_Show(hndl,iStatictext21) ;
003319  000461        
003320  000462      // Button6 1.0 generated 2/8/2013 11:11:51 PM
003321  000463      gfx_Button(1, 372, 236, RED, YELLOW, FONT1, 2, 2, "< Back") ;
003322  000464        
003323  000465      activeForm := 4;
003324  000466  endfunc
003325  000467        
003326  000468  func draw_form1()
003327  000469        
003328  000470      gfx_Cls();
003329  000471        
003330  000472        
003331  000473      if(direction & 0x01 == 0x01)
003332  000474          gfx_RectangleFilled(8, 40, 61, 150, 0x0000) ;
003333  000475          img_Show(hndl,iImage6) ;
003334  000476      else
003335  000477          gfx_RectangleFilled(8, 40, 61, 150, 0x0000) ;
003336  000478          img_Show(hndl,iImage5);
003337  000479      endif
003338  000480        
003339  000481      if(cruise & 0x01 == 0x01)
003340  000482          img_Enable(hndl,iImage7) ;
003341  000483          img_Show(hndl,iImage7) ;
003342  000484      else
003343  000485          img_Disable(hndl,iImage7) ;
003344  000486          gfx_RectangleFilled(6, 151, 59, 201, BLACK) ;
003345  000487      endif
003346  000488        
003347  000489      // dig_speed 1.0 generated 1/13/2013 11:35:34 PM
003348  000490      img_Show(hndl, idig_speed);  // show all digits at 0, only do this once
003349  000491      ledDigitsDisplay(speed, idig_speed+1, 76, 2, 1, 100, 1) ;
003350  000492        
003351  000493      // Statictext2 1.0 generated 1/13/2013 11:35:34 PM
003352  000494      img_Show(hndl,iStatictext2) ;
003353  000495        
003354  000496      // Image8 1.0 generated 3/4/2013 6:33:40 PM
003355  000497      img_Show(hndl,iImage8) ;
003356  000498        
003357  000499      // Line1 1.0 generated 1/13/2013 11:35:34 PM
003358  000500      gfx_Line(0, 236, 512, 236, SPRINGGREEN) ;
003359  000501        
003360  000502      // Button1 1.0 generated 1/13/2013 11:35:35 PM
003361  000503      gfx_Button(1, 392, 60, RED, YELLOW, FONT1, 2, 2, "Fuel") ;
003362  000504        
003363  000505      // Button2 1.0 generated 1/13/2013 11:35:35 PM
003364  000506      gfx_Button(1, 384, 188, RED, YELLOW, FONT1, 2, 2, "Temp.") ;
003365  000507        
003366  000508      // Line2 1.0 generated 1/13/2013 11:35:35 PM
003367  000509      gfx_Line(0, 30, 512, 30, SPRINGGREEN) ;
003368  000510        
003369  000511      // Button3 1.0 generated 1/13/2013 11:35:35 PM
003370  000512      gfx_Button(1, 380, 124, RED, YELLOW, FONT1, 2, 2, "Power") ;
003371  000513        
003372  000514      // Line3 1.0 generated 1/13/2013 11:35:35 PM
003373  000515      gfx_Line(340, 30, 340, 236, SPRINGGREEN) ;
003374  000516        
003375  000517      // Statictext3 1.0 generated 1/13/2013 11:35:35 PM
003376  000518      img_Show(hndl,iStatictext3) ;
003377  000519        
003378  000520      // dig_trip 1.0 generated 1/13/2013 11:35:35 PM
003379  000521      img_Show(hndl, idig_trip);  // show all digits at 0, only do this once
003380  000522      ledDigitsDisplay(trip, idig_trip+1, 344, 4, 2, 16, 0) ;
003381  000523        
003382  000524      // Statictext4 1.0 generated 1/13/2013 11:35:36 PM
003383  000525      img_Show(hndl,iStatictext4) ;
003384  000526        
003385  000527      // Image1 1.0 generated 1/13/2013 11:35:36 PM
003386  000528      img_Show(hndl,iImage1) ;
003387  000529        
003388  000530      // Statictext5 1.0 generated 1/13/2013 11:35:36 PM
003389  000531      img_Show(hndl,iStatictext5) ;
003390  000532        
003391  000533      // Statictext6 1.0 generated 1/13/2013 11:35:36 PM
003392  000534      img_Show(hndl,iStatictext6) ;
003393  000535        
003394  000536      // gauge_speed 1.0 generated 1/13/2013 11:35:36 PM
003395  000537      img_SetWord(hndl, igauge_speed, IMAGE_INDEX, speed*100/60) ; // where frame is 0 to 100 (for a displayed 0 to 100)
003396  000538      img_Show(hndl,igauge_speed) ;
003397  000539        
003398  000540      // dig_odo 1.0 generated 1/13/2013 11:35:36 PM
003399  000541      img_Show(hndl, idig_odo);  // show all digits at 0, only do this once
003400  000542      ledDigitsDisplay(odo, idig_odo+1, 72, 4, 1, 16, 0) ;
003401  000543        
003402  000544      // Image2 1.0 generated 1/13/2013 11:35:37 PM
003403  000545      img_Show(hndl,iImage2) ;
003404  000546        
003405  000547      // Image3 1.0 generated 1/13/2013 11:35:37 PM
003406  000548      img_Show(hndl,iImage3) ;
003407  000549        
003408  000550      // Image4 1.0 generated 1/13/2013 11:35:37 PM
003409  000551      img_Show(hndl,iImage4) ;
003410  000552      activeForm := 1;
003411  000553  endfunc
003412  000554        
003413  000555  func draw_form3()
003414  000556      gfx_Cls();
003415  000557        
003416  000558      // Statictext7 1.0 generated 2/10/2013 12:59:33 PM
003417  000559      img_Show(hndl,iStatictext7) ;
003418  000560        
003419  000561      // Button5 1.0 generated 2/10/2013 12:59:33 PM
003420  000562      gfx_Button(1, 372, 236, RED, YELLOW, FONT1, 2, 2, "< Back") ;
003421  000563        
003422  000564      // barStackV 1.0 generated 2/10/2013 12:59:33 PM
003423  000565      img_SetWord(hndl, ibarStackV, IMAGE_INDEX, vstack*2/3) ; // where frame is 0 to 100 (for a displayed 0 to 100)
003424  000566      img_Show(hndl,ibarStackV) ;
003425  000567        
003426  000568      // Statictext8 1.0 generated 2/10/2013 12:59:33 PM
003427  000569      img_Show(hndl,iStatictext8) ;
003428  000570        
003429  000571      // digStackV 1.0 generated 2/10/2013 12:59:33 PM
003430  000572      img_Show(hndl, idigStackV);  // show all digits at 0, only do this once
003431  000573      ledDigitsDisplay(vstack*10/3, idigStackV+1, 160, 3, 2, 16, 0) ;
003432  000574        
003433  000575      // Statictext9 1.0 generated 2/10/2013 12:59:34 PM
003434  000576      img_Show(hndl,iStatictext9) ;
003435  000577        
003436  000578      // Statictext10 1.0 generated 2/10/2013 12:59:34 PM
003437  000579      img_Show(hndl,iStatictext10) ;
003438  000580        
003439  000581      // Statictext11 1.0 generated 2/10/2013 12:59:34 PM
003440  000582      img_Show(hndl,iStatictext11) ;
003441  000583        
003442  000584      // Statictext12 1.0 generated 2/10/2013 12:59:34 PM
003443  000585      img_Show(hndl,iStatictext12) ;
003444  000586        
003445  000587      // Statictext13 1.0 generated 2/10/2013 12:59:34 PM
003446  000588      img_Show(hndl,iStatictext13) ;
003447  000589        
003448  000590      // Statictext16 1.0 generated 2/10/2013 12:59:34 PM
003449  000591      img_Show(hndl,iStatictext16) ;
003450  000592        
003451  000593      // barAccV 1.0 generated 2/10/2013 12:59:34 PM
003452  000594      img_SetWord(hndl, ibarAccV, IMAGE_INDEX, vaccessory*2/3) ; // where frame is 0 to 100 (for a displayed 0 to 100)
003453  000595      img_Show(hndl,ibarAccV) ;
003454  000596        
003455  000597      // ledFuelCellPwr 1.0 generated 2/10/2013 12:59:34 PM
003456  000598      img_Show(hndl,iledFuelCellPwr) ;  // show initialy, if required
003457  000599      img_SetWord(hndl, iledFuelCellPwr, IMAGE_INDEX, pwrFuelCell && 0x01) ;      // where numx is 0 (Off) or 1 (On)
003458  000600      img_Show(hndl,iledFuelCellPwr) ;
003459  000601        
003460  000602      // ledMotorPwr 1.0 generated 2/10/2013 12:59:34 PM
003461  000603      img_Show(hndl,iledMotorPwr) ;  // show initialy, if required
003462  000604      img_SetWord(hndl, iledMotorPwr, IMAGE_INDEX, pwrMotor) ;      // where numx is 0 (Off) or 1 (On)
003463  000605      img_Show(hndl,iledMotorPwr) ;
003464  000606        
003465  000607      // digAccV 1.0 generated 2/10/2013 12:59:34 PM
003466  000608      img_Show(hndl, idigAccV);  // show all digits at 0, only do this once
003467  000609      ledDigitsDisplay(vaccessory, idigAccV+1, 160, 3, 2, 16, 0) ;
003468  000610        
003469  000611      // Statictext14 1.0 generated 2/10/2013 12:59:34 PM
003470  000612      img_Show(hndl,iStatictext14) ;
003471  000613        
003472  000614      // digBuckBoostV 1.0 generated 2/10/2013 12:59:34 PM
003473  000615      img_Show(hndl, idigBuckBoostV);  // show all digits at 0, only do this once
003474  000616      ledDigitsDisplay(bbvoltage, idigBuckBoostV+1, 160, 3, 2, 16, 0) ;
003475  000617        
003476  000618      // digStackI 1.0 generated 2/10/2013 12:59:35 PM
003477  000619      img_Show(hndl, idigStackI);  // show all digits at 0, only do this once
003478  000620      ledDigitsDisplay(istack*2, idigStackI+1, 160, 3, 2, 16, 0) ;
003479  000621        
003480  000622      // digMotCurr1 1.0 generated 2/10/2013 12:59:35 PM
003481  000623      img_Show(hndl, idigMotCurr1);  // show all digits at 0, only do this once
003482  000624      ledDigitsDisplay(motcurr1, idigMotCurr1+1, 160, 3, 2, 16, 0) ;
003483  000625        
003484  000626      // digMotCurr2 1.0 generated 2/10/2013 12:59:35 PM
003485  000627      img_Show(hndl, idigMotCurr2);  // show all digits at 0, only do this once
003486  000628      ledDigitsDisplay(motcurr2, idigMotCurr2+1, 160, 3, 2, 16, 0) ;
003487  000629        
003488  000630      // Statictext15 1.0 generated 2/10/2013 12:59:35 PM
003489  000631      img_Show(hndl,iStatictext15) ;
003490  000632        
003491  000633      // Statictext17 1.0 generated 2/10/2013 12:59:35 PM
003492  000634      img_Show(hndl,iStatictext17) ;
003493  000635        
003494  000636      // Statictext18 1.0 generated 2/10/2013 12:59:35 PM
003495  000637      img_Show(hndl,iStatictext18) ;
003496  000638        
003497  000639      // Statictext19 1.0 generated 2/10/2013 12:59:35 PM
003498  000640      img_Show(hndl,iStatictext19) ;
003499  000641        
003500  000642      // barBuckBoostV 1.0 generated 2/10/2013 12:59:35 PM
003501  000643      img_SetWord(hndl, ibarBuckBoostV, IMAGE_INDEX, bbvoltage/6) ; // where frame is 0 to 100 (for a displayed 0 to 100)
003502  000644      img_Show(hndl,ibarBuckBoostV) ;
003503  000645        
003504  000646      // barStackI 1.0 generated 2/10/2013 12:59:35 PM
003505  000647      img_SetWord(hndl, ibarStackI, IMAGE_INDEX, istack*2/5) ; // where frame is 0 to 100 (for a displayed 0 to 100)
003506  000648      img_Show(hndl,ibarStackI) ;
003507  000649        
003508  000650      // barMotCurr1 1.0 generated 2/10/2013 12:59:35 PM
003509  000651      img_SetWord(hndl, ibarMotCurr1, IMAGE_INDEX, 0) ; // where frame is 0 to 100 (for a displayed 0 to 100)
003510  000652      img_Show(hndl,ibarMotCurr1) ;
003511  000653        
003512  000654      // barMotCurr2 1.0 generated 2/10/2013 12:59:35 PM
003513  000655      img_SetWord(hndl, ibarMotCurr2, IMAGE_INDEX, 0) ; // where frame is 0 to 100 (for a displayed 0 to 100)
003514  000656      img_Show(hndl,ibarMotCurr2) ;
003515  000657        
003516  000658       activeForm := 3;
003517  000659  endfunc
003518  000660        
003519  000661  func draw_form2()
003520  000662        
003521  000663      gfx_Cls();
003522  000664        
003523  000665      // temp_outside 1.0 generated 1/15/2013 12:53:55 AM
003524  000666      img_SetWord(hndl, itemp_outside, IMAGE_INDEX, temp_outside/2 + 30) ; // where frame is 0 to 70 (for a displayed -1 to -1)
003525  000667      img_Show(hndl,itemp_outside) ;
003526  000668        
003527  000669      // Button4 1.0 generated 1/15/2013 12:53:56 AM
003528  000670      gfx_Button(1, 372, 236, RED, YELLOW, FONT1, 2, 2, "< Back");
003529  000671        
003530  000672      // temp_cabin 1.0 generated 1/15/2013 12:53:56 AM
003531  000673      img_SetWord(hndl, itemp_cabin, IMAGE_INDEX, temp_cabin) ; // where frame is 0 to 70 (for a displayed -1 to -1)
003532  000674      img_Show(hndl,itemp_cabin) ;
003533  000675        
003534  000676      // temp_trunk 1.0 generated 1/15/2013 12:53:56 AM
003535  000677      img_SetWord(hndl, itemp_trunk, IMAGE_INDEX, temp_trunk) ; // where frame is 0 to 70 (for a displayed -1 to -1)
003536  000678      img_Show(hndl,itemp_trunk) ;
003537  000679        
003538  000680      // temp_fuelcell 1.0 generated 1/15/2013 12:53:56 AM
003539  000681      img_SetWord(hndl, itemp_fuelcell, IMAGE_INDEX, temp_fuelcell/2) ; // where frame is 0 to 70 (for a displayed -1 to -1)
003540  000682      img_Show(hndl,itemp_fuelcell) ;
003541  000683        
003542  000684      // Statictext1 1.0 generated 1/15/2013 12:53:56 AM
003543  000685      img_Show(hndl,iStatictext1) ;
003544  000686        
003545  000687       activeForm := 2;
003546  000688        
003547  000689  endfunc
003548  000690        
003549  000691        
003550  000692  func main()
003551  000693      pin_Set(OUTPUT, PIN_LCDOUT);     // Set pin to output for LCD_readReady
003552  000694      pin_Set(INPUT, PIN_PICIN);       // Set pin to input for PIC_hasNewData
003553  000695      pin_Set(INPUT, PIN_CALIBRATE);  // Pin used to enter display into emergency calibration/debug mode.
003554  000696        
003555  000697      pin_LO(PIN_LCDOUT);
003556  000698        
003557  000699      if(pin_Read(PIN_CALIBRATE))
003558  000700          file_Run("43TouchCal.4XE", 0);  // Run the emergency calibration program.
003559  000701      endif
003560  000702        
003561  000703      // Step 1: Mount the uSD file system:
003562  000704      putstr("Please wait. Mounting uSD File System....\n");
003563  000705      if (!(disk:=file_Mount()))
003564  000706          while(!(disk := file_Mount()))
003565  000707              putstr("Drive not mounted... Please insert uSD card!");
003566  000708              pause(200);
003567  000709              gfx_Cls();
003568  000710              pause(200);
003569  000711          wend
003570  000712      endif
003571  000713        
003572  000714      hndl := file_LoadImageControl("ECOCAR~1.dat", "ECOCAR~1.gci", 1);
003573  000715        
003574  000716      if (!hndl)
003575  000717          putstr("Failed to read image data from uSD!");
003576  000718          repeat forever
003577  000719      endif
003578  000720        
003579  000721      gfx_Cls();
003580  000722      touch_Set(TOUCH_ENABLE); // Enable touch screen.
003581  000723      gfx_TransparentColour(0x0020);
003582  000724      gfx_Transparency(ON);
003583  000725      gfx_Set(SCREEN_MODE, LANDSCAPE) ;    // Set screen to landscape mode.
003584  000726        
003585  000727      var hFile;
003586  000728      if(hFile := file_Open("ODO.TXT" ,'r'))
003587  000729          odo := file_GetW(hFile);    // Retrieve odometer value.
003588  000730          file_Close(hFile);
003589  000731      endif
003590  000732        
003591  000733      if(hFile := file_Open("ODOM.TXT" ,'r'))
003592  000734          odo_micro := file_GetW(hFile);    // Retrieve odometer small-scale value.
003593  000735          file_Close(hFile);
003594  000736      endif
003595  000737        
003596  000738      if(hFile := file_Open("TRIP.TXT" ,'r'))
003597  000739          trip := file_GetW(hFile);    // Retrieve trip odo small-scale value.
003598  000740          file_Close(hFile);
003599  000741      endif
003600  000742        
003601  000743      draw_form1();
003602  000744        
003603  000745      sys_SetTimerEvent(TIMER1, update_odo);
003604  000746      sys_SetTimerEvent(TIMER2, setBackupAlarm);
003605  000747      pokeW(SYSTEM_TIMER_LO, 0);
003606  000748      sys_SetTimer(TIMER1, 10);
003607  000749        
003608  000750        
003609  000751        
003610  000752      if(snd_Playing())
003611  000753          snd_Stop();
003612  000754      endif
003613  000755        
003614  000756       repeat
003615  000757          if(pin_Read(PIN_PICIN))
003616  000758              serial_read();
003617  000759          endif
003618  000760        
003619  000761          checkTouchEvents();
003620  000762      forever
003621  000763        
003622  000764  endfunc
003623  000765        
003624  000766  func checkTouchEvents()
003625  000767  if(touch_Get(TOUCH_STATUS) == TOUCH_PRESSED)
003626  000768              // Query the x and y coordinates of where we touched.
003627  000769              var x;
003628  000770              var y;
003629  000771              x := touch_Get(TOUCH_GETX);
003630  000772              y := touch_Get(TOUCH_GETY);
003631  000773              if(x >= 342 && activeForm == 1 && y > 40 && y < 225 && activeForm == 1)
003632  000774                  // Main menu options:
003633  000775                  if(y < 100)
003634  000776                      draw_form4();
003635  000777                  else if(y > 120 && y < 180)
003636  000778                      draw_form3();
003637  000779                  else if(y > 180)
003638  000780                      draw_form2();
003639  000781                  endif
003640  000782              else if(y <=35 && x >= 435 && activeForm == 1)
003641  000783                   reset_trip();
003642  000784              else if(activeForm != 1 && y > 200 && x >=350)
003643  000785                  draw_form1();
003644  000786              else if(activeForm == 1 && y < 255 && y > 230 && x > 1 && x < 60)
003645  000787                   play_sax_man();
003646  000788              else
003647  000789                  snd_Stop();
003648  000790                  if(activeForm == 1)
003649  000791                      clearErrors();
003650  000792                  endif
003651  000793              endif
003652  000794  endif
003653  000795  endfunc
003654  000796        
003655  000797  // Credits to Howard (http://www.4d.websitetoolbox.com/post?id=6069444&goto=nextnewest)
003656  000798  func ledDigitsDisplay2(var newval, var index, var left, var Digits, var MinDigits, var WidthDigit, var LeadingBlanks, var FastMode)
003657  000799      var private digitstate[6];
003658  000800      var i, k, l, lb ;
003659  000801      l := 1 ;
003660  000802      for (i := 1; i < Digits; i++)
003661  000803          l *= 10 ;
003662  000804      next
003663  000805      lb := LeadingBlanks ;
003664  000806      for (i := 0; i < Digits; i++)
003665  000807          k := newval / l ;
003666  000808          newval -= k * l ;
003667  000809          if ( lb && (i < Digits - MinDigits) )
003668  000810              if (k == 0)
003669  000811                  k := -1 ;
003670  000812              else
003671  000813                  lb := 0 ;
003672  000814              endif
003673  000815          endif
003674  000816          l /= 10 ;
003675  000817          if(FastMode)
003676  000818              if(digitstate[i] != k)
003677  000819                  img_SetWord(hndl, index, IMAGE_INDEX, k);
003678  000820                  img_SetWord(hndl, index, IMAGE_XPOS, left+i*WidthDigit) ;
003679  000821                  img_Show(hndl, index);
003680  000822              endif
003681  000823          else
003682  000824              img_SetWord(hndl, index, IMAGE_INDEX, k);
003683  000825              img_SetWord(hndl, index, IMAGE_XPOS, left+i*WidthDigit) ;
003684  000826              img_Show(hndl, index);
003685  000827          endif
003686  000828         digitstate[i] := k;
003687  000829      next
003688  000830  endfunc
003689  000831        
003690  000832  func play_alarm()
003691  000833      var r;
003692  000834      snd_Stop(); // Stop anything currently playing.
003693  000835      r := file_PlayWAV("Alarm.wav");
003694  000836      snd_Volume(127);
003695  000837        
003696  000838  endfunc
003697  000839        
003698  000840  func play_sax_man()
003699  000841      var r;
003700  000842      if(!snd_Playing())
003701  000843          r := file_PlayWAV("sax.wav");
003702  000844          snd_Volume(127);
003703  000845      else
003704  000846          snd_Stop();
003705  000847      endif
003706  000848        
003707  000849  endfunc
Notice: local var 'hFile' in func 'reset_trip' is never used (line 64 file:EcoCarMain.4Dg)


Symbol Table:
name                 decimal    hex
_1F                                  -40  0xffffffd8 (PmmC func) args[0] r=0  (not used)
__MAXMEM                           14400  0x00003840 (const dword)  (usage 1)
__MAXPROG                          14400  0x00003840 (const dword)  (usage 1)
__PLATFORM                             1  0x00000001 (const dword)  (not used)
ABS                                  -13  0xfffffff3 (PmmC func) args[1] r=1  (not used)
activeForm                            22  0x00000016 (mem) word (global)  (usage 109)
ALICEBLUE                          63455  0x0000f7df (const dword)  (not used)
ALL                                65535  0x0000ffff (const dword)  (not used)
ANTIQUEWHITE                       65370  0x0000ff5a (const dword)  (not used)
APPEND                                 0  0x00000000 (const dword)  (not used)
AQUA                                2047  0x000007ff (const dword)  (not used)
AQUAMARINE                         32762  0x00007ffa (const dword)  (not used)
AUDIO_ENABLE                           7  0x00000007 (const dword)  (not used)
AZURE                              63487  0x0000f7ff (const dword)  (not used)
BACKGROUND_COLOUR                     17  0x00000011 (const dword)  (not used)
BACKLITE                               6  0x00000006 (const dword)  (not used)
backupVal                             62  0x0000003e (mem) word (global)  (usage 22)
BAUD_110                               0  0x00000000 (const dword)  (not used)
BAUD_115200                           13  0x0000000d (const dword)  (not used)
BAUD_1200                              3  0x00000003 (const dword)  (not used)
BAUD_128000                           14  0x0000000e (const dword)  (not used)
BAUD_14400                             7  0x00000007 (const dword)  (not used)
BAUD_19200                             8  0x00000008 (const dword)  (not used)
BAUD_2400                              4  0x00000004 (const dword)  (not used)
BAUD_256000                           15  0x0000000f (const dword)  (not used)
BAUD_300                               1  0x00000001 (const dword)  (not used)
BAUD_300000                           16  0x00000010 (const dword)  (not used)
BAUD_31250                             9  0x00000009 (const dword)  (not used)
BAUD_375000                           17  0x00000011 (const dword)  (not used)
BAUD_38400                            10  0x0000000a (const dword)  (not used)
BAUD_4800                              5  0x00000005 (const dword)  (not used)
BAUD_500000                           18  0x00000012 (const dword)  (not used)
BAUD_56000                            11  0x0000000b (const dword)  (not used)
BAUD_57600                            12  0x0000000c (const dword)  (usage 3)
BAUD_600                               2  0x00000002 (const dword)  (not used)
BAUD_600000                           19  0x00000013 (const dword)  (not used)
BAUD_9600                              6  0x00000006 (const dword)  (not used)
bbvoltage                             50  0x00000032 (mem) word (global)  (usage 13)
BEIGE                              63419  0x0000f7bb (const dword)  (not used)
BEVEL_SHADOW                          29  0x0000001d (const dword)  (not used)
BEVEL_WIDTH                           28  0x0000001c (const dword)  (not used)
BIN                                    2  0x00000002 (const dword)  (not used)
BIN1                                 258  0x00000102 (const dword)  (not used)
BIN10                               2562  0x00000a02 (const dword)  (not used)
BIN10Z                              6658  0x00001a02 (const dword)  (not used)
BIN10ZB                            10754  0x00002a02 (const dword)  (not used)
BIN11                               2818  0x00000b02 (const dword)  (not used)
BIN11Z                              6914  0x00001b02 (const dword)  (not used)
BIN11ZB                            11010  0x00002b02 (const dword)  (not used)
BIN12                               3074  0x00000c02 (const dword)  (not used)
BIN12Z                              7170  0x00001c02 (const dword)  (not used)
BIN12ZB                            11266  0x00002c02 (const dword)  (not used)
BIN13                               3330  0x00000d02 (const dword)  (not used)
BIN13Z                              7426  0x00001d02 (const dword)  (not used)
BIN13ZB                            11522  0x00002d02 (const dword)  (not used)
BIN14                               3586  0x00000e02 (const dword)  (not used)
BIN14Z                              7682  0x00001e02 (const dword)  (not used)
BIN14ZB                            11778  0x00002e02 (const dword)  (not used)
BIN15                               3842  0x00000f02 (const dword)  (not used)
BIN15Z                              7938  0x00001f02 (const dword)  (not used)
BIN15ZB                            12034  0x00002f02 (const dword)  (not used)
BIN16                                  2  0x00000002 (const dword)  (not used)
BIN16Z                              4098  0x00001002 (const dword)  (not used)
BIN16ZB                             8194  0x00002002 (const dword)  (not used)
BIN1Z                               4354  0x00001102 (const dword)  (not used)
BIN1ZB                              8450  0x00002102 (const dword)  (not used)
BIN2                                 514  0x00000202 (const dword)  (not used)
BIN2Z                               4610  0x00001202 (const dword)  (not used)
BIN2ZB                              8706  0x00002202 (const dword)  (not used)
BIN3                                 770  0x00000302 (const dword)  (not used)
BIN3Z                               4866  0x00001302 (const dword)  (not used)
BIN3ZB                              8962  0x00002302 (const dword)  (not used)
BIN4                                1026  0x00000402 (const dword)  (not used)
BIN4Z                               5122  0x00001402 (const dword)  (not used)
BIN4ZB                              9218  0x00002402 (const dword)  (not used)
BIN5                                1282  0x00000502 (const dword)  (not used)
BIN5Z                               5378  0x00001502 (const dword)  (not used)
BIN5ZB                              9474  0x00002502 (const dword)  (not used)
BIN6                                1538  0x00000602 (const dword)  (not used)
BIN6Z                               5634  0x00001602 (const dword)  (not used)
BIN6ZB                              9730  0x00002602 (const dword)  (not used)
BIN7                                1794  0x00000702 (const dword)  (not used)
BIN7Z                               5890  0x00001702 (const dword)  (not used)
BIN7ZB                              9986  0x00002702 (const dword)  (not used)
BIN8                                2050  0x00000802 (const dword)  (not used)
BIN8Z                               6146  0x00001802 (const dword)  (not used)
BIN8ZB                             10242  0x00002802 (const dword)  (not used)
BIN9                                2306  0x00000902 (const dword)  (not used)
BIN9Z                               6402  0x00001902 (const dword)  (not used)
BIN9ZB                             10498  0x00002902 (const dword)  (not used)
BINZ                                4098  0x00001002 (const dword)  (not used)
BINZB                               8194  0x00002002 (const dword)  (not used)
BISQUE                             65336  0x0000ff38 (const dword)  (not used)
BLACK                                  0  0x00000000 (const dword)  (usage 6)
BLANCHEDALMOND                     65369  0x0000ff59 (const dword)  (not used)
BLUE                                  31  0x0000001f (const dword)  (not used)
BLUEVIOLET                         35164  0x0000895c (const dword)  (not used)
BOLD                                  16  0x00000010 (const dword)  (not used)
BOTTOM_POS                             5  0x00000005 (const dword)  (not used)
BROWN                              41285  0x0000a145 (const dword)  (not used)
BURLYWOOD                          56784  0x0000ddd0 (const dword)  (not used)
BUS_0                                  8  0x00000008 (const dword)  (not used)
BUS_1                                  9  0x00000009 (const dword)  (not used)
BUS_2                                 10  0x0000000a (const dword)  (not used)
BUS_3                                 11  0x0000000b (const dword)  (not used)
BUS_4                                 12  0x0000000c (const dword)  (not used)
BUS_5                                 13  0x0000000d (const dword)  (not used)
BUS_6                                 14  0x0000000e (const dword)  (not used)
BUS_7                                 15  0x0000000f (const dword)  (not used)
bus_In                               -45  0xffffffd3 (PmmC func) args[0] r=1  (not used)
bus_Out                              -46  0xffffffd2 (PmmC func) args[1] r=0  (not used)
BUS_RD_PIN                             4  0x00000004 (const dword)  (not used)
bus_Read                             -49  0xffffffcf (PmmC func) args[0] r=1  (not used)
bus_Set                              -47  0xffffffd1 (PmmC func) args[1] r=0  (not used)
BUS_WR_PIN                             5  0x00000005 (const dword)  (not used)
bus_Write                            -48  0xffffffd0 (PmmC func) args[1] r=0  (not used)
BUTTON_DOWN                            0  0x00000000 (const dword)  (not used)
BUTTON_UP                              1  0x00000001 (const dword)  (not used)
ByteSwap                            -215  0xffffff29 (PmmC func) args[1] r=1  (not used)
C:\Users\Mikester\Documents\GitHub\LCD-Display\EcoCarMain.4Dg    2709  0x00000a95 (const ??? 0)  (not used)
CADETBLUE                          23796  0x00005cf4 (const dword)  (not used)
ch                                    18  0x00000012 (mem) word (global)  (usage 15)
charheight                          -159  0xffffff61 (PmmC func) args[1] r=1  (not used)
CHARTREUSE                         32736  0x00007fe0 (const dword)  (not used)
charwidth                           -158  0xffffff62 (PmmC func) args[1] r=1  (not used)
checkTouchEvents                    1092  0x00000444 (User func) args[0] r=0  (usage 6)
CHOCOLATE                          54083  0x0000d343 (const dword)  (not used)
CHR                                  129  0x00000081 (const dword)  (not used)
CKMODE_0                               0  0x00000000 (const dword)  (not used)
CKMODE_1                               1  0x00000001 (const dword)  (not used)
CKMODE_2                               2  0x00000002 (const dword)  (not used)
CKMODE_3                               3  0x00000003 (const dword)  (not used)
clearErrors                         3467  0x00000d8b (User func) args[0] r=0  (usage 9)
CLIPPING                              19  0x00000013 (const dword)  (not used)
COLOUR16                               0  0x00000000 (const dword)  (not used)
COLOUR8                                1  0x00000001 (const dword)  (not used)
COLOUR_MODE                           27  0x0000001b (const dword)  (not used)
COM0                               63492  0x0000f804 (const dword)  (not used)
COM1                               63496  0x0000f808 (const dword)  (not used)
com1_Count                          -132  0xffffff7c (PmmC func) args[0] r=1  (not used)
com1_Error                          -134  0xffffff7a (PmmC func) args[0] r=1  (not used)
com1_Full                           -133  0xffffff7b (PmmC func) args[0] r=1  (not used)
com1_Init                           -130  0xffffff7e (PmmC func) args[3] r=0  (not used)
com1_Reset                          -131  0xffffff7d (PmmC func) args[0] r=0  (not used)
com1_Sync                           -135  0xffffff79 (PmmC func) args[0] r=1  (not used)
com1_TXbuffer                       -136  0xffffff78 (PmmC func) args[3] r=0  (not used)
com1_TXbufferHold                   -139  0xffffff75 (PmmC func) args[1] r=1  (not used)
com1_TXcount                        -137  0xffffff77 (PmmC func) args[0] r=1  (not used)
com1_TXemptyEvent                   -138  0xffffff76 (PmmC func) args[1] r=1  (not used)
com_Count                           -122  0xffffff86 (PmmC func) args[0] r=1  (usage 3)
com_Error                           -124  0xffffff84 (PmmC func) args[0] r=1  (not used)
com_Full                            -123  0xffffff85 (PmmC func) args[0] r=1  (usage 3)
com_Init                            -120  0xffffff88 (PmmC func) args[3] r=0  (usage 3)
com_Reset                           -121  0xffffff87 (PmmC func) args[0] r=0  (usage 6)
com_SetBaud                         -142  0xffffff72 (PmmC func) args[2] r=1  (not used)
com_Sync                            -125  0xffffff83 (PmmC func) args[0] r=1  (not used)
com_TXbuffer                        -126  0xffffff82 (PmmC func) args[3] r=0  (not used)
com_TXbufferHold                    -129  0xffffff7f (PmmC func) args[1] r=1  (not used)
com_TXcount                         -127  0xffffff81 (PmmC func) args[0] r=1  (not used)
com_TXemptyEvent                    -128  0xffffff80 (PmmC func) args[1] r=1  (not used)
combuf                                 4  0x00000004 (mem) word[3] (global)  (usage 3)
CONTRAST                              25  0x00000019 (const dword)  (not used)
CORAL                              64490  0x0000fbea (const dword)  (not used)
CORNFLOWERBLUE                     25789  0x000064bd (const dword)  (not used)
CORNSILK                           65499  0x0000ffdb (const dword)  (not used)
COS                                  -18  0xffffffee (PmmC func) args[1] r=1  (not used)
CRIMSON                            55463  0x0000d8a7 (const dword)  (not used)
cruise                                34  0x00000022 (mem) word (global)  (usage 10)
CY                                  -285  0xfffffee3 (PmmC func) args[0] r=1  (not used)
CYAN                                2047  0x000007ff (const dword)  (not used)
cycle                                 20  0x00000014 (mem) word (global)  (usage 10)
DARKBLUE                              17  0x00000011 (const dword)  (not used)
DARKCYAN                            1105  0x00000451 (const dword)  (not used)
DARKGOLDENROD                      48161  0x0000bc21 (const dword)  (not used)
DARKGRAY                           44373  0x0000ad55 (const dword)  (not used)
DARKGREEN                            800  0x00000320 (const dword)  (not used)
DARKKHAKI                          48557  0x0000bdad (const dword)  (not used)
DARKMAGENTA                        34833  0x00008811 (const dword)  (not used)
DARKOLIVEGREEN                     21317  0x00005345 (const dword)  (not used)
DARKORANGE                         64608  0x0000fc60 (const dword)  (not used)
DARKORCHID                         39321  0x00009999 (const dword)  (not used)
DARKRED                            34816  0x00008800 (const dword)  (not used)
DARKSALMON                         60591  0x0000ecaf (const dword)  (not used)
DARKSEAGREEN                       36337  0x00008df1 (const dword)  (not used)
DARKSLATEBLUE                      18929  0x000049f1 (const dword)  (not used)
DARKSLATEGRAY                      10857  0x00002a69 (const dword)  (not used)
DARKTURQUOISE                       1658  0x0000067a (const dword)  (not used)
DARKVIOLET                         36890  0x0000901a (const dword)  (not used)
DEC                                 1290  0x0000050a (const dword)  (usage 6)
DEC1                                 266  0x0000010a (const dword)  (not used)
DEC1Z                               4362  0x0000110a (const dword)  (not used)
DEC1ZB                              8458  0x0000210a (const dword)  (not used)
DEC2                                 522  0x0000020a (const dword)  (not used)
DEC2Z                               4618  0x0000120a (const dword)  (not used)
DEC2ZB                              8714  0x0000220a (const dword)  (not used)
DEC3                                 778  0x0000030a (const dword)  (not used)
DEC3Z                               4874  0x0000130a (const dword)  (not used)
DEC3ZB                              8970  0x0000230a (const dword)  (not used)
DEC4                                1034  0x0000040a (const dword)  (not used)
DEC4Z                               5130  0x0000140a (const dword)  (not used)
DEC4ZB                              9226  0x0000240a (const dword)  (not used)
DEC5                                1290  0x0000050a (const dword)  (not used)
DEC5Z                               5386  0x0000150a (const dword)  (not used)
DEC5ZB                              9482  0x0000250a (const dword)  (not used)
DECZ                                5386  0x0000150a (const dword)  (not used)
DECZB                               9482  0x0000250a (const dword)  (not used)
DEEPPINK                           63666  0x0000f8b2 (const dword)  (not used)
DEEPSKYBLUE                         1535  0x000005ff (const dword)  (not used)
digitstate                        UNRESOLVED  (usage 4)
DIMGRAY                            27469  0x00006b4d (const dword)  (not used)
direction                             36  0x00000024 (mem) word (global)  (usage 13)
DISABLE                                0  0x00000000 (const dword)  (not used)
disk                                   0  0x00000000 (mem) word (global)  (usage 6)
DISK_BUF                              15  0x0000000f (const dword)  (not used)
DISK_DATA_HI                           7  0x00000007 (const dword)  (not used)
DISK_DATA_LO                           6  0x00000006 (const dword)  (not used)
DISK_FAT_HI                            3  0x00000003 (const dword)  (not used)
DISK_FAT_LO                            2  0x00000002 (const dword)  (not used)
DISK_FATCOPIES                        12  0x0000000c (const dword)  (not used)
DISK_FATSIZE                          11  0x0000000b (const dword)  (not used)
DISK_FIRST_SECT_HI                     1  0x00000001 (const dword)  (not used)
DISK_FIRST_SECT_LO                     0  0x00000000 (const dword)  (not used)
DISK_MAXCLUS_HI                        9  0x00000009 (const dword)  (not used)
DISK_MAXCLUS_LO                        8  0x00000008 (const dword)  (not used)
DISK_MAXROOT                          10  0x0000000a (const dword)  (not used)
DISK_ROOT_HI                           5  0x00000005 (const dword)  (not used)
DISK_ROOT_LO                           4  0x00000004 (const dword)  (not used)
DISK_SECT_PER_CLUS                    13  0x0000000d (const dword)  (not used)
DISK_TYPE                             14  0x0000000e (const dword)  (not used)
disp_Init                           -143  0xffffff71 (PmmC func) args[0] r=0  (not used)
disp_ReadWord                       -149  0xffffff6b (PmmC func) args[0] r=1  (not used)
disp_setGRAM                        -145  0xffffff6f (PmmC func) args[4] r=0  (not used)
disp_SetReg                         -144  0xffffff70 (PmmC func) args[2] r=0  (not used)
disp_Sync                           -284  0xfffffee4 (PmmC func) args[1] r=0  (not used)
disp_WrGRAM                         -146  0xffffff6e (PmmC func) args[1] r=0  (not used)
disp_WriteControl                   -147  0xffffff6d (PmmC func) args[1] r=0  (not used)
disp_WriteWord                      -148  0xffffff6c (PmmC func) args[1] r=0  (not used)
dispErrorMsg                        3524  0x00000dc4 (User func) args[3] r=0  (usage 3)
DISPLAY_PAGE                          33  0x00000021 (const dword)  (not used)
DODGERBLUE                          7327  0x00001c9f (const dword)  (not used)
DOWN                                   0  0x00000000 (const dword)  (not used)
draw_form1                          2703  0x00000a8f (User func) args[0] r=0  (usage 12)
draw_form2                          1929  0x00000789 (User func) args[0] r=0  (usage 3)
draw_form3                          2085  0x00000825 (User func) args[0] r=0  (usage 3)
draw_form4                          3211  0x00000c8b (User func) args[0] r=0  (usage 3)
DSK                                63490  0x0000f802 (const dword)  (not used)
ENABLE                                 1  0x00000001 (const dword)  (not used)
EVE_SP                              -282  0xfffffee6 (PmmC func) args[0] r=1  (not used)
EVE_SSIZE                           -283  0xfffffee5 (PmmC func) args[0] r=1  (not used)
FE_CANNOT_INIT                        15  0x0000000f (const dword)  (not used)
FE_CANNOT_READ_MBR                    16  0x00000010 (const dword)  (not used)
FE_DIR_FULL                           12  0x0000000c (const dword)  (not used)
FE_DISK_FULL                          13  0x0000000d (const dword)  (not used)
FE_DISK_NOT_MNTD                       6  0x00000006 (const dword)  (not used)
FE_EOF                                10  0x0000000a (const dword)  (not used)
FE_FAT_EOF                             9  0x00000009 (const dword)  (not used)
FE_FILE_NOT_FOUND                      7  0x00000007 (const dword)  (not used)
FE_FILE_OVERWRITE                     14  0x0000000e (const dword)  (not used)
FE_FIND_ERROR                         19  0x00000013 (const dword)  (not used)
FE_IDE_ERROR                           1  0x00000001 (const dword)  (not used)
FE_INVALID_BR                          5  0x00000005 (const dword)  (not used)
FE_INVALID_CLUSTER                    11  0x0000000b (const dword)  (not used)
FE_INVALID_FILE                        8  0x00000008 (const dword)  (not used)
FE_INVALID_FNAME                      20  0x00000014 (const dword)  (not used)
FE_INVALID_MBR                         4  0x00000004 (const dword)  (not used)
FE_INVALID_MEDIA                      21  0x00000015 (const dword)  (not used)
FE_INVALID_MODE                       18  0x00000012 (const dword)  (not used)
FE_MALLOC_FAILED                      17  0x00000011 (const dword)  (not used)
FE_NOT_PRESENT                         2  0x00000002 (const dword)  (not used)
FE_OK                                  0  0x00000000 (const dword)  (not used)
FE_PARTITION_TYPE                      3  0x00000003 (const dword)  (not used)
FE_SECTOR_READ_FAIL                   22  0x00000016 (const dword)  (not used)
FE_SECTOR_WRITE_FAIL                  23  0x00000017 (const dword)  (not used)
FILE_ATTRIBUTES                       18  0x00000012 (const dword)  (not used)
FILE_BUFFER                           22  0x00000016 (const dword)  (not used)
file_Close                          -232  0xffffff18 (PmmC func) args[1] r=1  (usage 18)
file_Count                          -226  0xffffff1e (PmmC func) args[1] r=1  (not used)
FILE_CURR_CLUSTER                      1  0x00000001 (const dword)  (not used)
FILE_CURR_SECTOR                       2  0x00000002 (const dword)  (not used)
FILE_CURR_SECTOR_POS                   3  0x00000003 (const dword)  (not used)
FILE_CURR_SECTOR_TOP                   4  0x00000004 (const dword)  (not used)
FILE_DATE                             10  0x0000000a (const dword)  (not used)
file_Dir                            -227  0xffffff1d (PmmC func) args[1] r=1  (not used)
FILE_DISK                             21  0x00000015 (const dword)  (not used)
FILE_ENTRY                            20  0x00000014 (const dword)  (not used)
file_Erase                          -247  0xffffff09 (PmmC func) args[1] r=1  (usage 12)
file_Error                          -225  0xffffff1f (PmmC func) args[0] r=1  (not used)
file_Exec                           -251  0xffffff05 (PmmC func) args[2] r=1  (not used)
file_Exists                         -230  0xffffff1a (PmmC func) args[1] r=1  (usage 12)
file_FindFirst                      -228  0xffffff1c (PmmC func) args[1] r=1  (not used)
file_FindNext                       -229  0xffffff1b (PmmC func) args[0] r=1  (not used)
FILE_FIRST_CLUSTER                     0  0x00000000 (const dword)  (not used)
file_GetC                           -242  0xffffff0e (PmmC func) args[1] r=1  (not used)
file_GetS                           -246  0xffffff0a (PmmC func) args[3] r=1  (not used)
file_GetW                           -244  0xffffff0c (PmmC func) args[1] r=1  (usage 9)
file_Image                          -239  0xffffff11 (PmmC func) args[3] r=1  (not used)
file_Index                          -235  0xffffff15 (PmmC func) args[4] r=1  (not used)
file_LoadFunction                   -249  0xffffff07 (PmmC func) args[1] r=1  (not used)
file_LoadImageControl               -252  0xffffff04 (PmmC func) args[3] r=1  (usage 3)
FILE_MODE                             17  0x00000011 (const dword)  (not used)
file_Mount                          -253  0xffffff03 (PmmC func) args[0] r=1  (usage 6)
FILE_NAME                             11  0x0000000b (const dword)  (not used)
file_Open                           -231  0xffffff19 (PmmC func) args[2] r=1  (usage 18)
FILE_PAGEFLAG                         19  0x00000013 (const dword)  (not used)
file_PlayWAV                        -255  0xffffff01 (PmmC func) args[1] r=1  (usage 15)
file_PutC                           -241  0xffffff0f (PmmC func) args[2] r=1  (not used)
file_PutS                           -245  0xffffff0b (PmmC func) args[2] r=1  (not used)
file_PutW                           -243  0xffffff0d (PmmC func) args[2] r=1  (usage 9)
file_Read                           -233  0xffffff17 (PmmC func) args[3] r=1  (not used)
file_Rewind                         -248  0xffffff08 (PmmC func) args[1] r=1  (not used)
file_Run                            -250  0xffffff06 (PmmC func) args[2] r=1  (usage 3)
file_ScreenCapture                  -240  0xffffff10 (PmmC func) args[5] r=1  (not used)
file_Seek                           -234  0xffffff16 (PmmC func) args[3] r=1  (not used)
FILE_SEEK_POS_HI                       6  0x00000006 (const dword)  (not used)
FILE_SEEK_POS_LO                       5  0x00000005 (const dword)  (not used)
file_Size                           -238  0xffffff12 (PmmC func) args[3] r=1  (not used)
FILE_SIZE_HI                           8  0x00000008 (const dword)  (not used)
FILE_SIZE_LO                           7  0x00000007 (const dword)  (not used)
file_Tell                           -236  0xffffff14 (PmmC func) args[3] r=1  (not used)
FILE_TIME                              9  0x00000009 (const dword)  (not used)
file_Unmount                        -254  0xffffff02 (PmmC func) args[0] r=0  (not used)
file_Write                          -237  0xffffff13 (PmmC func) args[3] r=1  (not used)
FIREBRICK                          45316  0x0000b104 (const dword)  (not used)
flash_BlockErase                    -157  0xffffff63 (PmmC func) args[1] r=1  (not used)
flash_BulkErase                     -156  0xffffff64 (PmmC func) args[0] r=0  (not used)
flash_ID                            -155  0xffffff65 (PmmC func) args[0] r=1  (not used)
flash_SIG                           -154  0xffffff66 (PmmC func) args[0] r=1  (not used)
FLORALWHITE                        65502  0x0000ffde (const dword)  (not used)
FONT1                                  0  0x00000000 (const dword)  (usage 18)
FONT2                                  1  0x00000001 (const dword)  (not used)
FONT3                                  2  0x00000002 (const dword)  (not used)
FONT_ID                                2  0x00000002 (const dword)  (not used)
FONT_SIZE                              2  0x00000002 (const dword)  (not used)
FORESTGREEN                         9284  0x00002444 (const dword)  (not used)
FRAME_DELAY                           22  0x00000016 (const dword)  (not used)
FUCHSIA                            63519  0x0000f81f (const dword)  (not used)
GAINSBORO                          57083  0x0000defb (const dword)  (not used)
GFX                                63489  0x0000f801 (const dword)  (not used)
gfx_332to565                         -85  0xffffffab (PmmC func) args[1] r=1  (not used)
gfx_BevelShadow                     -104  0xffffff98 (PmmC func) args[1] r=1  (not used)
gfx_BevelWidth                      -103  0xffffff99 (PmmC func) args[1] r=1  (not used)
gfx_BGcolour                         -92  0xffffffa4 (PmmC func) args[1] r=1  (not used)
GFX_BOTTOM                            51  0x00000033 (const dword)  (not used)
gfx_BoxTo                            -74  0xffffffb6 (PmmC func) args[2] r=0  (not used)
gfx_Bullet                           -71  0xffffffb9 (PmmC func) args[1] r=0  (not used)
gfx_Button                           -80  0xffffffb0 (PmmC func) args[9] r=0  (usage 18)
GFX_BUTTON_BACKGROUND                 64  0x00000040 (const dword)  (not used)
GFX_BUTTON_FOREGROUND                 63  0x0000003f (const dword)  (not used)
GFX_BUTTON_MODE                       65  0x00000041 (const dword)  (not used)
gfx_ChangeColour                     -76  0xffffffb4 (PmmC func) args[2] r=0  (not used)
gfx_Circle                           -61  0xffffffc3 (PmmC func) args[4] r=0  (not used)
gfx_CircleFilled                     -62  0xffffffc2 (PmmC func) args[4] r=0  (not used)
GFX_CLIP_BOTTOM                      114  0x00000072 (const dword)  (not used)
GFX_CLIP_BOTTOM_VAL                  110  0x0000006e (const dword)  (not used)
GFX_CLIP_LEFT                        111  0x0000006f (const dword)  (not used)
GFX_CLIP_LEFT_VAL                    107  0x0000006b (const dword)  (not used)
GFX_CLIP_RIGHT                       113  0x00000071 (const dword)  (not used)
GFX_CLIP_RIGHT_VAL                   109  0x0000006d (const dword)  (not used)
GFX_CLIP_TOP                         112  0x00000070 (const dword)  (not used)
GFX_CLIP_TOP_VAL                     108  0x0000006c (const dword)  (not used)
gfx_Clipping                         -94  0xffffffa2 (PmmC func) args[1] r=0  (not used)
gfx_ClipWindow                       -75  0xffffffb5 (PmmC func) args[4] r=0  (not used)
gfx_Cls                              -51  0xffffffcd (PmmC func) args[0] r=0  (usage 18)
gfx_ColourMode                      -102  0xffffff9a (PmmC func) args[1] r=1  (not used)
gfx_Contrast                        -100  0xffffff9c (PmmC func) args[1] r=1  (not used)
gfx_Dot                              -70  0xffffffba (PmmC func) args[0] r=0  (not used)
gfx_Ellipse                          -78  0xffffffb2 (PmmC func) args[5] r=0  (not used)
gfx_EllipseFilled                    -79  0xffffffb1 (PmmC func) args[5] r=0  (not used)
gfx_FrameDelay                       -97  0xffffff9f (PmmC func) args[1] r=1  (not used)
gfx_Get                              -90  0xffffffa6 (PmmC func) args[1] r=1  (not used)
gfx_GetPixel                         -64  0xffffffc0 (PmmC func) args[2] r=1  (not used)
GFX_HILIGHT_BACKGROUND                61  0x0000003d (const dword)  (not used)
GFX_HILIGHT_FOREGROUND                62  0x0000003e (const dword)  (not used)
GFX_HILITE_LINE                       58  0x0000003a (const dword)  (not used)
gfx_Hline                            -57  0xffffffc7 (PmmC func) args[4] r=1  (not used)
gfx_IncX                             -72  0xffffffb8 (PmmC func) args[0] r=1  (not used)
gfx_IncY                             -73  0xffffffb7 (PmmC func) args[0] r=1  (not used)
GFX_LAST_CHAR_HEIGHT                 120  0x00000078 (const dword)  (not used)
GFX_LAST_CHAR_WIDTH                  119  0x00000077 (const dword)  (not used)
GFX_LAST_SELECTION                    60  0x0000003c (const dword)  (not used)
GFX_LAST_STR_HEIGHT                  122  0x0000007a (const dword)  (not used)
GFX_LAST_STR_WIDTH                   121  0x00000079 (const dword)  (not used)
GFX_LEFT                              48  0x00000030 (const dword)  (not used)
GFX_LEFT_GUTTER_WIDTH                 68  0x00000044 (const dword)  (not used)
gfx_Line                             -56  0xffffffc8 (PmmC func) args[5] r=0  (usage 9)
GFX_LINE_COUNT                        59  0x0000003b (const dword)  (not used)
gfx_LinePattern                     -101  0xffffff9b (PmmC func) args[1] r=1  (not used)
gfx_LineRel                          -55  0xffffffc9 (PmmC func) args[2] r=0  (not used)
gfx_LineTo                           -54  0xffffffca (PmmC func) args[2] r=0  (not used)
gfx_MoveRel                          -53  0xffffffcb (PmmC func) args[2] r=0  (not used)
gfx_MoveTo                           -52  0xffffffcc (PmmC func) args[2] r=0  (not used)
gfx_ObjectColour                     -93  0xffffffa3 (PmmC func) args[1] r=1  (not used)
gfx_Orbit                            -67  0xffffffbd (PmmC func) args[2] r=0  (not used)
gfx_OrbitInit                        -66  0xffffffbe (PmmC func) args[2] r=0  (not used)
gfx_Origin                           -89  0xffffffa7 (PmmC func) args[2] r=0  (not used)
gfx_OutlineColour                    -99  0xffffff9d (PmmC func) args[1] r=1  (not used)
gfx_Panel                            -81  0xffffffaf (PmmC func) args[6] r=0  (not used)
gfx_PenSize                          -91  0xffffffa5 (PmmC func) args[1] r=1  (not used)
GFX_PIXEL_SHIFT                       70  0x00000046 (const dword)  (not used)
gfx_Polygon                          -69  0xffffffbb (PmmC func) args[4] r=0  (not used)
gfx_PolygonFilled                    -88  0xffffffa8 (PmmC func) args[4] r=0  (not used)
gfx_Polyline                         -68  0xffffffbc (PmmC func) args[4] r=0  (not used)
gfx_PutPixel                         -63  0xffffffc1 (PmmC func) args[3] r=0  (not used)
GFX_RECT_X1                           71  0x00000047 (const dword)  (not used)
GFX_RECT_X2                           73  0x00000049 (const dword)  (not used)
GFX_RECT_Y1                           72  0x00000048 (const dword)  (not used)
GFX_RECT_Y2                           74  0x0000004a (const dword)  (not used)
gfx_Rectangle                        -59  0xffffffc5 (PmmC func) args[5] r=0  (not used)
gfx_RectangleFilled                  -60  0xffffffc4 (PmmC func) args[5] r=0  (usage 18)
gfx_RGBto565                         -84  0xffffffac (PmmC func) args[3] r=1  (not used)
GFX_RIGHT                             50  0x00000032 (const dword)  (not used)
GFX_RIGHT_GUTTER_WIDTH                69  0x00000045 (const dword)  (not used)
gfx_ScreenCopyPaste                  -83  0xffffffad (PmmC func) args[6] r=0  (not used)
gfx_ScreenMode                       -98  0xffffff9e (PmmC func) args[1] r=1  (not used)
gfx_Selection                        -86  0xffffffaa (PmmC func) args[3] r=0  (not used)
gfx_Set                              -50  0xffffffce (PmmC func) args[2] r=0  (usage 3)
gfx_SetClipRegion                    -77  0xffffffb3 (PmmC func) args[0] r=0  (not used)
gfx_Slider                           -82  0xffffffae (PmmC func) args[8] r=1  (not used)
GFX_STATUSBAR_HEIGHT                  67  0x00000043 (const dword)  (not used)
GFX_THUMB_BORDER_DARK                 76  0x0000004c (const dword)  (not used)
GFX_THUMB_BORDER_LIGHT                77  0x0000004d (const dword)  (not used)
GFX_THUMB_PERCENT                     75  0x0000004b (const dword)  (not used)
GFX_TOOLBAR_HEIGHT                    66  0x00000042 (const dword)  (not used)
GFX_TOP                               49  0x00000031 (const dword)  (not used)
GFX_TOUCH_REGION_X1                  103  0x00000067 (const dword)  (not used)
GFX_TOUCH_REGION_X2                  105  0x00000069 (const dword)  (not used)
GFX_TOUCH_REGION_Y1                  104  0x00000068 (const dword)  (not used)
GFX_TOUCH_REGION_Y2                  106  0x0000006a (const dword)  (not used)
gfx_Transparency                     -96  0xffffffa0 (PmmC func) args[1] r=1  (usage 3)
gfx_TransparentColour                -95  0xffffffa1 (PmmC func) args[1] r=1  (usage 3)
gfx_Triangle                         -65  0xffffffbf (PmmC func) args[7] r=0  (not used)
gfx_TriangleFilled                   -87  0xffffffa9 (PmmC func) args[7] r=0  (not used)
gfx_Vline                            -58  0xffffffc6 (PmmC func) args[4] r=1  (not used)
GFX_X1                                52  0x00000034 (const dword)  (not used)
GFX_X2                                54  0x00000036 (const dword)  (not used)
GFX_X_ORG                             56  0x00000038 (const dword)  (not used)
GFX_XMAX                              46  0x0000002e (const dword)  (not used)
gfx_Xorigin                         -105  0xffffff97 (PmmC func) args[1] r=1  (not used)
GFX_Y1                                53  0x00000035 (const dword)  (not used)
GFX_Y2                                55  0x00000037 (const dword)  (not used)
GFX_Y_ORG                             57  0x00000039 (const dword)  (not used)
GFX_YMAX                              47  0x0000002f (const dword)  (not used)
gfx_Yorigin                         -106  0xffffff96 (PmmC func) args[1] r=1  (not used)
GHOSTWHITE                         65503  0x0000ffdf (const dword)  (not used)
GOLD                               65184  0x0000fea0 (const dword)  (not used)
GOLDENROD                          56612  0x0000dd24 (const dword)  (not used)
GRAM_PIXEL_COUNT_HI                  116  0x00000074 (const dword)  (not used)
GRAM_PIXEL_COUNT_LO                  115  0x00000073 (const dword)  (not used)
GRAY                               33808  0x00008410 (const dword)  (not used)
GREEN                               1024  0x00000400 (const dword)  (not used)
GREENYELLOW                        45029  0x0000afe5 (const dword)  (not used)
HEX                                 5136  0x00001410 (const dword)  (usage 12)
HEX1                                4368  0x00001110 (const dword)  (not used)
HEX1Z                                272  0x00000110 (const dword)  (not used)
HEX1ZB                              8464  0x00002110 (const dword)  (not used)
HEX2                                4624  0x00001210 (const dword)  (not used)
HEX2Z                                528  0x00000210 (const dword)  (not used)
HEX2ZB                              8720  0x00002210 (const dword)  (not used)
HEX3                                4880  0x00001310 (const dword)  (not used)
HEX3Z                                784  0x00000310 (const dword)  (not used)
HEX3ZB                              8976  0x00002310 (const dword)  (not used)
HEX4                                5136  0x00001410 (const dword)  (not used)
HEX4Z                               1040  0x00000410 (const dword)  (not used)
HEX4ZB                              9232  0x00002410 (const dword)  (not used)
HEXZ                                1040  0x00000410 (const dword)  (not used)
HEXZB                               9232  0x00002410 (const dword)  (not used)
HI                                     1  0x00000001 (const dword)  (not used)
HIbyte                              -214  0xffffff2a (PmmC func) args[1] r=1  (not used)
HIDE                                   2  0x00000002 (const dword)  (not used)
hndl                                   2  0x00000002 (mem) word (global)  (usage 339)
HONEYDEW                           63486  0x0000f7fe (const dword)  (not used)
HOTPINK                            64342  0x0000fb56 (const dword)  (not used)
I2C                                63520  0x0000f820 (const dword)  (not used)
I2C_Ack                             -169  0xffffff57 (PmmC func) args[0] r=0  (not used)
I2C_AckPoll                         -172  0xffffff54 (PmmC func) args[1] r=1  (not used)
I2C_AckStatus                       -171  0xffffff55 (PmmC func) args[0] r=0  (not used)
I2C_Close                           -163  0xffffff5d (PmmC func) args[0] r=0  (not used)
I2C_FAST                               2  0x00000002 (const dword)  (not used)
I2C_Getn                            -175  0xffffff51 (PmmC func) args[2] r=1  (not used)
I2C_Gets                            -174  0xffffff52 (PmmC func) args[2] r=1  (not used)
I2C_Idle                            -173  0xffffff53 (PmmC func) args[0] r=0  (not used)
I2C_MED                                1  0x00000001 (const dword)  (not used)
I2C_Nack                            -170  0xffffff56 (PmmC func) args[0] r=0  (not used)
I2C_Open                            -162  0xffffff5e (PmmC func) args[1] r=0  (not used)
I2C_Putn                            -177  0xffffff4f (PmmC func) args[2] r=1  (not used)
I2C_Puts                            -176  0xffffff50 (PmmC func) args[1] r=1  (not used)
I2C_Read                            -167  0xffffff59 (PmmC func) args[0] r=1  (not used)
I2C_Restart                         -166  0xffffff5a (PmmC func) args[0] r=1  (not used)
I2C_SLOW                               0  0x00000000 (const dword)  (not used)
I2C_Start                           -164  0xffffff5c (PmmC func) args[0] r=1  (not used)
I2C_Stop                            -165  0xffffff5b (PmmC func) args[0] r=1  (not used)
I2C_Write                           -168  0xffffff58 (PmmC func) args[1] r=1  (not used)
I_COLOUR16                            16  0x00000010 (const dword)  (not used)
I_DARKEN                           16384  0x00004000 (const dword)  (not used)
I_ENABLED                          32768  0x00008000 (const dword)  (not used)
I_LIGHTEN                           8192  0x00002000 (const dword)  (not used)
I_MOVIE                              128  0x00000080 (const dword)  (not used)
I_NOGROUP                             64  0x00000040 (const dword)  (not used)
I_STAYONTOP                          256  0x00000100 (const dword)  (not used)
I_TOPMOST                            512  0x00000200 (const dword)  (not used)
I_TOUCH_DISABLE                       32  0x00000020 (const dword)  (not used)
I_TOUCHED                           4096  0x00001000 (const dword)  (not used)
I_X_LOCK                            1024  0x00000400 (const dword)  (not used)
I_Y_LOCK                            2048  0x00000800 (const dword)  (not used)
iAngularmeter1                        59  0x0000003b (const ??? 0)  (usage 6)
ibarAccV                              36  0x00000024 (const ??? 0)  (usage 12)
ibarBuckBoostV                        54  0x00000036 (const ??? 0)  (usage 12)
ibarMotCurr1                          56  0x00000038 (const ??? 0)  (usage 12)
ibarMotCurr2                          57  0x00000039 (const ??? 0)  (usage 12)
ibarStackI                            55  0x00000037 (const ??? 0)  (usage 12)
ibarStackV                            26  0x0000001a (const ??? 0)  (usage 12)
idig_odo                              11  0x0000000b (const ??? 0)  (usage 9)
idig_speed                             0  0x00000000 (const ??? 0)  (usage 9)
idig_trip                              4  0x00000004 (const ??? 0)  (usage 15)
idigAccV                              39  0x00000027 (const ??? 0)  (usage 9)
idigBuckBoostV                        42  0x0000002a (const ??? 0)  (usage 9)
idigMotCurr1                          46  0x0000002e (const ??? 0)  (usage 9)
idigMotCurr2                          48  0x00000030 (const ??? 0)  (usage 9)
idigStackI                            44  0x0000002c (const ??? 0)  (usage 9)
idigStackV                            28  0x0000001c (const ??? 0)  (usage 9)
igauge_speed                          10  0x0000000a (const ??? 0)  (usage 12)
iidig_odo                             12  0x0000000c (const ??? 0)  (not used)
iidig_speed                            1  0x00000001 (const ??? 0)  (not used)
iidig_trip                             5  0x00000005 (const ??? 0)  (not used)
iidigAccV                             40  0x00000028 (const ??? 0)  (not used)
iidigBuckBoostV                       43  0x0000002b (const ??? 0)  (not used)
iidigMotCurr1                         47  0x0000002f (const ??? 0)  (not used)
iidigMotCurr2                         49  0x00000031 (const ??? 0)  (not used)
iidigStackI                           45  0x0000002d (const ??? 0)  (not used)
iidigStackV                           29  0x0000001d (const ??? 0)  (not used)
iImage1                                7  0x00000007 (const ??? 0)  (usage 3)
iImage2                               13  0x0000000d (const ??? 0)  (usage 3)
iImage3                               14  0x0000000e (const ??? 0)  (usage 3)
iImage4                               15  0x0000000f (const ??? 0)  (usage 3)
iImage5                               16  0x00000010 (const ??? 0)  (usage 6)
iImage6                               17  0x00000011 (const ??? 0)  (usage 6)
iImage7                               18  0x00000012 (const ??? 0)  (usage 18)
iImage8                               19  0x00000013 (const ??? 0)  (usage 3)
iledFuelCellPwr                       37  0x00000025 (const ??? 0)  (usage 15)
iledMotorPwr                          38  0x00000026 (const ??? 0)  (usage 15)
IMAGE_CLUSTER                         10  0x0000000a (const dword)  (not used)
IMAGE_DELAY                            7  0x00000007 (const dword)  (not used)
IMAGE_FLAGS                            6  0x00000006 (const dword)  (not used)
IMAGE_FRAMES                           8  0x00000008 (const dword)  (not used)
IMAGE_HEIGHT                           5  0x00000005 (const dword)  (not used)
IMAGE_HIWORD                           1  0x00000001 (const dword)  (not used)
IMAGE_INDEX                            9  0x00000009 (const dword)  (usage 90)
IMAGE_LOWORD                           0  0x00000000 (const dword)  (not used)
IMAGE_SECTOR                          11  0x0000000b (const dword)  (not used)
IMAGE_TAG                             12  0x0000000c (const dword)  (not used)
IMAGE_TAG2                            13  0x0000000d (const dword)  (not used)
IMAGE_WIDTH                            4  0x00000004 (const dword)  (not used)
IMAGE_XPOS                             2  0x00000002 (const dword)  (usage 9)
IMAGE_YPOS                             3  0x00000003 (const dword)  (not used)
img_ClearAttributes                 -187  0xffffff45 (PmmC func) args[3] r=1  (not used)
IMG_COUNT                              0  0x00000000 (const dword)  (not used)
IMG_CURRENT_FRAME                     89  0x00000059 (const dword)  (not used)
img_Darken                          -181  0xffffff4b (PmmC func) args[2] r=1  (not used)
IMG_DAT_FILENAME                       4  0x00000004 (const dword)  (not used)
img_Disable                         -180  0xffffff4c (PmmC func) args[2] r=1  (usage 6)
img_Enable                          -179  0xffffff4d (PmmC func) args[2] r=1  (usage 6)
IMG_ENTRYLEN                           1  0x00000001 (const dword)  (not used)
IMG_FLAGS                             85  0x00000055 (const dword)  (not used)
IMG_FRAME_COUNT                       86  0x00000056 (const dword)  (not used)
IMG_FRAME_DELAY                       84  0x00000054 (const dword)  (not used)
IMG_GCI_FILENAME                       3  0x00000003 (const dword)  (not used)
IMG_GCIFILE_HANDLE                     5  0x00000005 (const dword)  (not used)
img_GetWord                         -184  0xffffff48 (PmmC func) args[3] r=1  (not used)
IMG_HEIGHT                            83  0x00000053 (const dword)  (not used)
img_Lighten                         -182  0xffffff4a (PmmC func) args[2] r=1  (not used)
IMG_MODE                               2  0x00000002 (const dword)  (not used)
IMG_PIXEL_COUNT_HI                    88  0x00000058 (const dword)  (not used)
IMG_PIXEL_COUNT_LO                    87  0x00000057 (const dword)  (not used)
img_SetAttributes                   -186  0xffffff46 (PmmC func) args[3] r=1  (not used)
img_SetPosition                     -178  0xffffff4e (PmmC func) args[4] r=1  (not used)
img_SetWord                         -183  0xffffff49 (PmmC func) args[4] r=1  (usage 99)
img_Show                            -185  0xffffff47 (PmmC func) args[2] r=1  (usage 222)
img_Touched                         -188  0xffffff44 (PmmC func) args[2] r=1  (not used)
IMG_WIDTH                             82  0x00000052 (const dword)  (not used)
INDIANRED                          51947  0x0000caeb (const dword)  (not used)
INDIGO                             18448  0x00004810 (const dword)  (not used)
INPUT                                  1  0x00000001 (const dword)  (usage 6)
INVERSE                               64  0x00000040 (const dword)  (not used)
IO1_PIN                                1  0x00000001 (const dword)  (not used)
IO2_PIN                                2  0x00000002 (const dword)  (not used)
IO3_PIN                                3  0x00000003 (const dword)  (not used)
IO4_PIN                                4  0x00000004 (const dword)  (not used)
IO5_PIN                                5  0x00000005 (const dword)  (not used)
isalnum                             -207  0xffffff31 (PmmC func) args[1] r=1  (not used)
isalpha                             -206  0xffffff32 (PmmC func) args[1] r=1  (not used)
isdigit                             -202  0xffffff36 (PmmC func) args[1] r=1  (not used)
islower                             -205  0xffffff33 (PmmC func) args[1] r=1  (not used)
isprint                             -208  0xffffff30 (PmmC func) args[1] r=1  (not used)
isspace                             -209  0xffffff2f (PmmC func) args[1] r=1  (not used)
istack                                52  0x00000034 (mem) word (global)  (usage 16)
iStatictext1                          24  0x00000018 (const ??? 0)  (usage 3)
iStatictext10                         31  0x0000001f (const ??? 0)  (usage 3)
iStatictext11                         32  0x00000020 (const ??? 0)  (usage 3)
iStatictext12                         33  0x00000021 (const ??? 0)  (usage 3)
iStatictext13                         34  0x00000022 (const ??? 0)  (usage 3)
iStatictext14                         41  0x00000029 (const ??? 0)  (usage 3)
iStatictext15                         50  0x00000032 (const ??? 0)  (usage 3)
iStatictext16                         35  0x00000023 (const ??? 0)  (usage 3)
iStatictext17                         51  0x00000033 (const ??? 0)  (usage 3)
iStatictext18                         52  0x00000034 (const ??? 0)  (usage 3)
iStatictext19                         53  0x00000035 (const ??? 0)  (usage 3)
iStatictext2                           2  0x00000002 (const ??? 0)  (usage 3)
iStatictext20                         58  0x0000003a (const ??? 0)  (usage 3)
iStatictext21                         60  0x0000003c (const ??? 0)  (usage 3)
iStatictext3                           3  0x00000003 (const ??? 0)  (usage 3)
iStatictext4                           6  0x00000006 (const ??? 0)  (usage 3)
iStatictext5                           8  0x00000008 (const ??? 0)  (usage 3)
iStatictext6                           9  0x00000009 (const ??? 0)  (usage 3)
iStatictext7                          25  0x00000019 (const ??? 0)  (usage 3)
iStatictext8                          27  0x0000001b (const ??? 0)  (usage 3)
iStatictext9                          30  0x0000001e (const ??? 0)  (usage 3)
isupper                             -204  0xffffff34 (PmmC func) args[1] r=1  (not used)
iswhite                             -210  0xffffff2e (PmmC func) args[1] r=1  (not used)
isxdigit                            -203  0xffffff35 (PmmC func) args[1] r=1  (not used)
ITALIC                                32  0x00000020 (const dword)  (not used)
itemp_cabin                           21  0x00000015 (const ??? 0)  (usage 12)
itemp_fuelcell                        23  0x00000017 (const ??? 0)  (usage 12)
itemp_outside                         20  0x00000014 (const ??? 0)  (usage 12)
itemp_trunk                           22  0x00000016 (const ??? 0)  (usage 12)
iterator                            -198  0xffffff3a (PmmC func) args[1] r=0  (not used)
IVORY                              65534  0x0000fffe (const dword)  (not used)
KHAKI                              63281  0x0000f731 (const dword)  (not used)
LANDSCAPE                              0  0x00000000 (const dword)  (usage 3)
LANDSCAPE_R                            1  0x00000001 (const dword)  (not used)
lastTimeout                           66  0x00000042 (mem) word (global)  (usage 25)
LAVENDER                           59199  0x0000e73f (const dword)  (not used)
LAVENDERBLUSH                      65438  0x0000ff9e (const dword)  (not used)
LAWNGREEN                          32736  0x00007fe0 (const dword)  (not used)
ledDigitsDisplay                    6037  0x00001795 (User func) args[7] r=0  (usage 54)
ledDigitsDisplay2                    821  0x00000335 (User func) args[8] r=0  (usage 3)
ledDigitsDisplay2.digitstate          68  0x00000044 (mem) word[6] (member of ledDigitsDisplay2)  (usage 2)
LEFT_POS                               2  0x00000002 (const dword)  (not used)
LEMONCHIFFON                       65497  0x0000ffd9 (const dword)  (not used)
LIGHTBLUE                          44764  0x0000aedc (const dword)  (not used)
LIGHTCORAL                         62480  0x0000f410 (const dword)  (not used)
LIGHTCYAN                          59391  0x0000e7ff (const dword)  (not used)
LIGHTGOLD                          65498  0x0000ffda (const dword)  (not used)
LIGHTGREEN                         38770  0x00009772 (const dword)  (not used)
LIGHTGREY                          54938  0x0000d69a (const dword)  (not used)
LIGHTPINK                          64952  0x0000fdb8 (const dword)  (not used)
LIGHTSALMON                        64783  0x0000fd0f (const dword)  (not used)
LIGHTSEAGREEN                       9621  0x00002595 (const dword)  (not used)
LIGHTSKYBLUE                       34431  0x0000867f (const dword)  (not used)
LIGHTSLATEGRAY                     29779  0x00007453 (const dword)  (not used)
LIGHTSTEELBLUE                     46651  0x0000b63b (const dword)  (not used)
LIGHTYELLOW                        65532  0x0000fffc (const dword)  (not used)
LIME                                2016  0x000007e0 (const dword)  (not used)
LIMEGREEN                          13926  0x00003666 (const dword)  (not used)
LINE_PATTERN                          26  0x0000001a (const dword)  (not used)
LINEN                              65436  0x0000ff9c (const dword)  (not used)
LO                                     0  0x00000000 (const dword)  (not used)
LObyte                              -213  0xffffff2b (PmmC func) args[1] r=1  (not used)
LPCOARSE                           61680  0x0000f0f0 (const dword)  (not used)
LPDASHDOT                            975  0x000003cf (const dword)  (not used)
LPDASHDOTDOT                         819  0x00000333 (const dword)  (not used)
LPFINE                             43690  0x0000aaaa (const dword)  (not used)
LPMEDIUM                           13107  0x00003333 (const dword)  (not used)
LPSOLID                                0  0x00000000 (const dword)  (not used)
MAGENTA                            63519  0x0000f81f (const dword)  (not used)
main                                1535  0x000005ff (User func) args[0] r=0  (not used)
MAROON                             32768  0x00008000 (const dword)  (not used)
MAX                                  -15  0xfffffff1 (PmmC func) args[2] r=1  (not used)
MDA                                63552  0x0000f840 (const dword)  (not used)
MEDIA_ADDRESS_HI                      91  0x0000005b (const dword)  (not used)
MEDIA_ADDRESS_LO                      90  0x0000005a (const dword)  (not used)
media_Flush                         -118  0xffffff8a (PmmC func) args[0] r=1  (not used)
media_Image                         -117  0xffffff8b (PmmC func) args[2] r=0  (not used)
media_Init                          -119  0xffffff89 (PmmC func) args[0] r=1  (not used)
media_RdSector                      -111  0xffffff91 (PmmC func) args[1] r=1  (not used)
media_ReadByte                      -113  0xffffff8f (PmmC func) args[0] r=1  (not used)
media_ReadWord                      -114  0xffffff8e (PmmC func) args[0] r=1  (not used)
MEDIA_SECTOR_COUNT                    94  0x0000005e (const dword)  (not used)
MEDIA_SECTOR_HI                       93  0x0000005d (const dword)  (not used)
MEDIA_SECTOR_LO                       92  0x0000005c (const dword)  (not used)
media_SetAdd                        -109  0xffffff93 (PmmC func) args[2] r=0  (not used)
media_SetSector                     -110  0xffffff92 (PmmC func) args[2] r=0  (not used)
media_Video                         -107  0xffffff95 (PmmC func) args[2] r=0  (not used)
media_VideoFrame                    -108  0xffffff94 (PmmC func) args[3] r=0  (not used)
media_WriteByte                     -115  0xffffff8d (PmmC func) args[1] r=1  (not used)
media_WriteWord                     -116  0xffffff8c (PmmC func) args[1] r=1  (not used)
media_WrSector                      -112  0xffffff90 (PmmC func) args[1] r=1  (not used)
MEDIUMAQUAMARINE                   26229  0x00006675 (const dword)  (not used)
MEDIUMBLUE                            25  0x00000019 (const dword)  (not used)
MEDIUMORCHID                       47802  0x0000baba (const dword)  (not used)
MEDIUMPURPLE                       37787  0x0000939b (const dword)  (not used)
MEDIUMSEAGREEN                     15758  0x00003d8e (const dword)  (not used)
MEDIUMSLATEBLUE                    31581  0x00007b5d (const dword)  (not used)
MEDIUMSPRINGGREEN                   2003  0x000007d3 (const dword)  (not used)
MEDIUMTURQUOISE                    20121  0x00004e99 (const dword)  (not used)
MEDIUMVIOLETRED                    49328  0x0000c0b0 (const dword)  (not used)
mem_Alloc                           -216  0xffffff28 (PmmC func) args[1] r=1  (not used)
mem_AllocV                          -217  0xffffff27 (PmmC func) args[1] r=1  (not used)
mem_AllocZ                          -218  0xffffff26 (PmmC func) args[1] r=1  (not used)
mem_Compare                         -224  0xffffff20 (PmmC func) args[3] r=1  (not used)
mem_Copy                            -223  0xffffff21 (PmmC func) args[3] r=1  (not used)
mem_Free                            -220  0xffffff24 (PmmC func) args[1] r=1  (not used)
mem_Heap                            -221  0xffffff23 (PmmC func) args[0] r=1  (not used)
mem_Realloc                         -219  0xffffff25 (PmmC func) args[2] r=1  (not used)
mem_Set                             -222  0xffffff22 (PmmC func) args[3] r=1  (not used)
MIDI                                   9  0x00000009 (const dword)  (not used)
MIDNIGHTBLUE                        6350  0x000018ce (const dword)  (not used)
MIN                                  -14  0xfffffff2 (PmmC func) args[2] r=1  (not used)
MINTCREAM                          63487  0x0000f7ff (const dword)  (not used)
MISTYROSE                          65340  0x0000ff3c (const dword)  (not used)
MOCCASIN                           65334  0x0000ff36 (const dword)  (not used)
motcurr1                              54  0x00000036 (mem) word (global)  (usage 10)
motcurr2                              56  0x00000038 (mem) word (global)  (usage 10)
n                                     16  0x00000010 (mem) word (global)  (usage 9)
NAVAJOWHITE                        65269  0x0000fef5 (const dword)  (not used)
NAVY                                  16  0x00000010 (const dword)  (not used)
NOTOUCH                                0  0x00000000 (const dword)  (not used)
OBJECT_COLOUR                         18  0x00000012 (const dword)  (not used)
odo                                   28  0x0000001c (mem) word (global)  (usage 19)
odo_micro                             30  0x0000001e (mem) word (global)  (usage 25)
OFF                                    0  0x00000000 (const dword)  (not used)
OLDLACE                            65468  0x0000ffbc (const dword)  (not used)
OLIVE                              33792  0x00008400 (const dword)  (not used)
OLIVEDRAB                          27748  0x00006c64 (const dword)  (not used)
ON                                     1  0x00000001 (const dword)  (usage 3)
OPAQUE                                 1  0x00000001 (const dword)  (not used)
ORANGE                             64800  0x0000fd20 (const dword)  (not used)
ORANGERED                          64032  0x0000fa20 (const dword)  (not used)
ORCHID                             56218  0x0000db9a (const dword)  (not used)
OUTLINE                                1  0x00000001 (const dword)  (not used)
OUTLINE_COLOUR                        24  0x00000018 (const dword)  (not used)
OUTPUT                                 0  0x00000000 (const dword)  (usage 3)
OVF                                  -21  0xffffffeb (PmmC func) args[0] r=1  (not used)
PALEGOLDENROD                      61269  0x0000ef55 (const dword)  (not used)
PALEGREEN                          40915  0x00009fd3 (const dword)  (not used)
PALETURQUOISE                      44925  0x0000af7d (const dword)  (not used)
PALEVIOLETRED                      56210  0x0000db92 (const dword)  (not used)
PANEL_HIDE                             2  0x00000002 (const dword)  (not used)
PANEL_RAISED                           1  0x00000001 (const dword)  (not used)
PANEL_SUNKEN                           0  0x00000000 (const dword)  (not used)
PAPAYAWHIP                         65402  0x0000ff7a (const dword)  (not used)
pause                                 -6  0xfffffffa (PmmC func) args[1] r=0  (usage 6)
PEACHPUFF                          65239  0x0000fed7 (const dword)  (not used)
peekW                                -11  0xfffffff5 (PmmC func) args[1] r=1  (usage 3)
PEN_SIZE                              16  0x00000010 (const dword)  (not used)
PERU                               52263  0x0000cc27 (const dword)  (not used)
PICASO                                 1  0x00000001 (const dword)  (usage 3)
PICASO_FUNCTIONS                       0  0x00000000 (const ??? 0)  (not used)
PIN_CALIBRATE                          3  0x00000003 (const dword)  (usage 6)
pin_HI                               -42  0xffffffd6 (PmmC func) args[1] r=1  (usage 3)
PIN_LCDOUT                             1  0x00000001 (const dword)  (usage 12)
pin_LO                               -43  0xffffffd5 (PmmC func) args[1] r=1  (usage 6)
PIN_PICIN                              2  0x00000002 (const dword)  (usage 9)
pin_Read                             -44  0xffffffd4 (PmmC func) args[1] r=1  (usage 9)
pin_Set                              -41  0xffffffd7 (PmmC func) args[2] r=1  (usage 9)
PINK                               65049  0x0000fe19 (const dword)  (not used)
play_alarm                           794  0x0000031a (User func) args[0] r=0  (usage 3)
play_sax_man                         755  0x000002f3 (User func) args[0] r=0  (usage 3)
PLUM                               56603  0x0000dd1b (const dword)  (not used)
pokeW                                -12  0xfffffff4 (PmmC func) args[2] r=0  (usage 6)
PORTRAIT                               2  0x00000002 (const dword)  (not used)
PORTRAIT_R                             3  0x00000003 (const dword)  (not used)
POWDERBLUE                         46876  0x0000b71c (const dword)  (not used)
process_serial_data                 4229  0x00001085 (User func) args[3] r=0  (usage 3)
PROGRESSBAR_HIDE                       2  0x00000002 (const dword)  (not used)
PROGRESSBAR_RAISED                 65535  0x0000ffff (const dword)  (not used)
PROGRESSBAR_SUNKEN                 65534  0x0000fffe (const dword)  (not used)
ptank                                 64  0x00000040 (mem) word (global)  (usage 4)
PURPLE                             32784  0x00008010 (const dword)  (not used)
putch                                 -2  0xfffffffe (PmmC func) args[1] r=0  (not used)
putnum                                -7  0xfffffff9 (PmmC func) args[2] r=1  (not used)
putstr                                -9  0xfffffff7 (PmmC func) args[1] r=1  (usage 9)
pwrFuelCell                           58  0x0000003a (mem) word (global)  (usage 10)
pwrMotor                              60  0x0000003c (mem) word (global)  (usage 10)
RAND                                 -19  0xffffffed (PmmC func) args[0] r=1  (not used)
RANDOM_HI                             33  0x00000021 (const dword)  (not used)
RANDOM_LO                             32  0x00000020 (const dword)  (not used)
READ_PAGE                             34  0x00000022 (const dword)  (not used)
RED                                63488  0x0000f800 (const dword)  (usage 24)
reset_trip                          5962  0x0000174a (User func) args[0] r=0  (usage 3)
RIGHT_POS                              4  0x00000004 (const dword)  (not used)
ROSYBROWN                          48241  0x0000bc71 (const dword)  (not used)
ROYALBLUE                          17244  0x0000435c (const dword)  (not used)
RUNFLASH                             128  0x00000080 (const dword)  (not used)
RXMODE_0                               0  0x00000000 (const dword)  (not used)
RXMODE_1                               1  0x00000001 (const dword)  (not used)
SADDLEBROWN                        35362  0x00008a22 (const dword)  (not used)
SALMON                             64526  0x0000fc0e (const dword)  (not used)
SANDYBROWN                         62764  0x0000f52c (const dword)  (not used)
SCREEN_MODE                           23  0x00000017 (const dword)  (usage 3)
SEAGREEN                           11338  0x00002c4a (const dword)  (not used)
SEASHELL                           65469  0x0000ffbd (const dword)  (not used)
SEED                                 -20  0xffffffec (PmmC func) args[1] r=0  (not used)
SELECT                                 3  0x00000003 (const dword)  (not used)
SELECT_MULTIPLE                        4  0x00000004 (const dword)  (not used)
serial_read                         3296  0x00000ce0 (User func) args[0] r=0  (usage 3)
serin                                 -1  0xffffffff (PmmC func) args[0] r=1  (usage 3)
serin1                              -140  0xffffff74 (PmmC func) args[0] r=1  (not used)
serout                                -3  0xfffffffd (PmmC func) args[1] r=0  (not used)
serout1                             -141  0xffffff73 (PmmC func) args[1] r=0  (not used)
setBackupAlarm                      3990  0x00000f96 (User func) args[0] r=0  (usage 3)
setbaud                               -4  0xfffffffc (PmmC func) args[1] r=0  (usage 3)
SIENNA                             41605  0x0000a285 (const dword)  (not used)
SILVER                             50712  0x0000c618 (const dword)  (not used)
SIN                                  -17  0xffffffef (PmmC func) args[1] r=1  (not used)
SKYBLUE                            34429  0x0000867d (const dword)  (not used)
SLATEBLUE                          27353  0x00006ad9 (const dword)  (not used)
SLATEGRAY                          29714  0x00007412 (const dword)  (not used)
SLIDER_HIDE                            2  0x00000002 (const dword)  (not used)
SLIDER_RAISED                          1  0x00000001 (const dword)  (not used)
SLIDER_SUNKEN                          0  0x00000000 (const dword)  (not used)
snd_BufSize                         -258  0xfffffefe (PmmC func) args[1] r=0  (not used)
snd_Continue                        -261  0xfffffefb (PmmC func) args[0] r=0  (not used)
snd_Pause                           -260  0xfffffefc (PmmC func) args[0] r=0  (not used)
snd_Pitch                           -257  0xfffffeff (PmmC func) args[1] r=1  (not used)
snd_Playing                         -262  0xfffffefa (PmmC func) args[0] r=1  (usage 15)
snd_Stop                            -259  0xfffffefd (PmmC func) args[0] r=0  (usage 12)
snd_Volume                          -256  0xffffff00 (PmmC func) args[1] r=0  (usage 9)
SNOW                               65503  0x0000ffdf (const dword)  (not used)
SOLID                                  0  0x00000000 (const dword)  (not used)
speed                                 24  0x00000018 (mem) word (global)  (usage 25)
spi_Disable                         -153  0xffffff67 (PmmC func) args[0] r=0  (not used)
SPI_FAST                               0  0x00000000 (const dword)  (not used)
spi_Init                            -150  0xffffff6a (PmmC func) args[3] r=0  (not used)
SPI_MED                                1  0x00000001 (const dword)  (not used)
spi_Read                            -151  0xffffff69 (PmmC func) args[0] r=1  (not used)
SPI_SLOW                               2  0x00000002 (const dword)  (not used)
spi_Write                           -152  0xffffff68 (PmmC func) args[1] r=0  (not used)
SPRINGGREEN                         2031  0x000007ef (const dword)  (usage 9)
SQRT                                 -22  0xffffffea (PmmC func) args[1] r=1  (not used)
SSD1963_ENTER_IDLE_MODE               57  0x00000039 (const dword)  (not used)
SSD1963_ENTER_INVERT_MODE             33  0x00000021 (const dword)  (not used)
SSD1963_ENTER_NORMAL_MODE             19  0x00000013 (const dword)  (not used)
SSD1963_ENTER_PARTIAL_MODE            18  0x00000012 (const dword)  (not used)
SSD1963_ENTER_SLEEP_MODE              16  0x00000010 (const dword)  (not used)
SSD1963_EXIT_IDLE_MODE                56  0x00000038 (const dword)  (not used)
SSD1963_EXIT_INVERT_MODE              32  0x00000020 (const dword)  (not used)
SSD1963_EXIT_SLEEP_MODE               17  0x00000011 (const dword)  (not used)
SSD1963_GET_ADDRESS_MODE              11  0x0000000b (const dword)  (not used)
SSD1963_GET_DBC_CONF                 209  0x000000d1 (const dword)  (not used)
SSD1963_GET_DBC_TH                   213  0x000000d5 (const dword)  (not used)
SSD1963_GET_DISPLAY_MODE              13  0x0000000d (const dword)  (not used)
SSD1963_GET_GPIO0_ROP                201  0x000000c9 (const dword)  (not used)
SSD1963_GET_GPIO1_ROP                203  0x000000cb (const dword)  (not used)
SSD1963_GET_GPIO2_ROP                205  0x000000cd (const dword)  (not used)
SSD1963_GET_GPIO3_ROP                207  0x000000cf (const dword)  (not used)
SSD1963_GET_GPIO_CONFIG              185  0x000000b9 (const dword)  (not used)
SSD1963_GET_GPIO_STATUS              187  0x000000bb (const dword)  (not used)
SSD1963_GET_HORZ_PERIOD              181  0x000000b5 (const dword)  (not used)
SSD1963_GET_LCD_GEN0                 192  0x000000c0 (const dword)  (not used)
SSD1963_GET_LCD_GEN1                 194  0x000000c2 (const dword)  (not used)
SSD1963_GET_LCD_GEN2                 196  0x000000c4 (const dword)  (not used)
SSD1963_GET_LCD_GEN3                 198  0x000000c6 (const dword)  (not used)
SSD1963_GET_LCD_MODE                 177  0x000000b1 (const dword)  (not used)
SSD1963_GET_LSHIFT_FREQ              231  0x000000e7 (const dword)  (not used)
SSD1963_GET_PIXEL_DATA_INTERFACE     241  0x000000f1 (const dword)  (not used)
SSD1963_GET_PLL_MN                   227  0x000000e3 (const dword)  (not used)
SSD1963_GET_PLL_STATUS               228  0x000000e4 (const dword)  (not used)
SSD1963_GET_POST_PROC                189  0x000000bd (const dword)  (not used)
SSD1963_GET_POWER_MODE                10  0x0000000a (const dword)  (not used)
SSD1963_GET_PWM_CONFIG               191  0x000000bf (const dword)  (not used)
SSD1963_GET_SCANLINE                  69  0x00000045 (const dword)  (not used)
SSD1963_GET_TEAR_EFFECT_STATUS        14  0x0000000e (const dword)  (not used)
SSD1963_GET_VERT_PERIOD              183  0x000000b7 (const dword)  (not used)
SSD1963_NOP                            0  0x00000000 (const dword)  (not used)
SSD1963_READ_DDB                     161  0x000000a1 (const dword)  (not used)
SSD1963_READ_MEMORY_CONTINUE          62  0x0000003e (const dword)  (not used)
SSD1963_READ_MEMORY_START             46  0x0000002e (const dword)  (not used)
SSD1963_SET_ADDRESS_MODE              54  0x00000036 (const dword)  (not used)
SSD1963_SET_COLUMN_ADDRESS            42  0x0000002a (const dword)  (not used)
SSD1963_SET_DBC_CONF                 208  0x000000d0 (const dword)  (not used)
SSD1963_SET_DBC_TH                   212  0x000000d4 (const dword)  (not used)
SSD1963_SET_DEEP_SLEEP               229  0x000000e5 (const dword)  (not used)
SSD1963_SET_DISPLAY_OFF               40  0x00000028 (const dword)  (not used)
SSD1963_SET_DISPLAY_ON                41  0x00000029 (const dword)  (not used)
SSD1963_SET_GAMMA_CURVE               38  0x00000026 (const dword)  (not used)
SSD1963_SET_GPIO0_ROP                200  0x000000c8 (const dword)  (not used)
SSD1963_SET_GPIO1_ROP                202  0x000000ca (const dword)  (not used)
SSD1963_SET_GPIO2_ROP                204  0x000000cc (const dword)  (not used)
SSD1963_SET_GPIO3_ROP                206  0x000000ce (const dword)  (not used)
SSD1963_SET_GPIO_CONFIG              184  0x000000b8 (const dword)  (not used)
SSD1963_SET_GPIO_VALUE               186  0x000000ba (const dword)  (not used)
SSD1963_SET_HORZ_PERIOD              180  0x000000b4 (const dword)  (not used)
SSD1963_SET_LCD_GEN0                 193  0x000000c1 (const dword)  (not used)
SSD1963_SET_LCD_GEN1                 195  0x000000c3 (const dword)  (not used)
SSD1963_SET_LCD_GEN2                 197  0x000000c5 (const dword)  (not used)
SSD1963_SET_LCD_GEN3                 199  0x000000c7 (const dword)  (not used)
SSD1963_SET_LCD_MODE                 176  0x000000b0 (const dword)  (not used)
SSD1963_SET_LSHIFT_FREQ              230  0x000000e6 (const dword)  (not used)
SSD1963_SET_PAGE_ADDRESS              43  0x0000002b (const dword)  (not used)
SSD1963_SET_PARTIAL_AREA              48  0x00000030 (const dword)  (not used)
SSD1963_SET_PLL                      224  0x000000e0 (const dword)  (not used)
SSD1963_SET_PLL_MN                   226  0x000000e2 (const dword)  (not used)
SSD1963_SET_POST_PROC                188  0x000000bc (const dword)  (not used)
SSD1963_SET_PWM_CONFIG               190  0x000000be (const dword)  (not used)
SSD1963_SET_REAR_ON                   53  0x00000035 (const dword)  (not used)
SSD1963_SET_SCROLL_AREA               51  0x00000033 (const dword)  (not used)
SSD1963_SET_SCROLL_START              55  0x00000037 (const dword)  (not used)
SSD1963_SET_TEAR_OFF                  52  0x00000034 (const dword)  (not used)
SSD1963_SET_TEAR_SCANLINE             68  0x00000044 (const dword)  (not used)
SSD1963_SET_VERT_PERIOD              182  0x000000b6 (const dword)  (not used)
SSD1963_SOFT_RESET                     1  0x00000001 (const dword)  (not used)
SSD1963_WRITE_MEMORY_CONTINUE         60  0x0000003c (const dword)  (not used)
SSD1963_WRITE_MEMORY_START            44  0x0000002c (const dword)  (not used)
STEELBLUE                          17430  0x00004416 (const dword)  (not used)
STR                                  128  0x00000080 (const dword)  (not used)
str_ByteMove                        -286  0xfffffee2 (PmmC func) args[3] r=1  (not used)
str_Cat                             -278  0xfffffeea (PmmC func) args[2] r=1  (not used)
str_CatN                            -279  0xfffffee9 (PmmC func) args[3] r=1  (not used)
str_Copy                            -287  0xfffffee1 (PmmC func) args[2] r=1  (not used)
str_CopyN                           -288  0xfffffee0 (PmmC func) args[3] r=1  (not used)
str_Find                            -274  0xfffffeee (PmmC func) args[2] r=1  (not used)
str_FindI                           -275  0xfffffeed (PmmC func) args[2] r=1  (not used)
str_GetByte                         -268  0xfffffef4 (PmmC func) args[1] r=1  (not used)
str_GetC                            -267  0xfffffef5 (PmmC func) args[2] r=1  (not used)
str_GetD                            -264  0xfffffef8 (PmmC func) args[2] r=1  (not used)
str_GetHexW                         -266  0xfffffef6 (PmmC func) args[2] r=1  (not used)
str_GetW                            -265  0xfffffef7 (PmmC func) args[2] r=1  (not used)
str_GetWord                         -269  0xfffffef3 (PmmC func) args[1] r=1  (not used)
str_Length                          -276  0xfffffeec (PmmC func) args[1] r=1  (not used)
str_Match                           -272  0xfffffef0 (PmmC func) args[2] r=1  (not used)
str_MatchI                          -273  0xfffffeef (PmmC func) args[2] r=1  (not used)
str_Printf                          -277  0xfffffeeb (PmmC func) args[2] r=1  (not used)
str_Ptr                             -263  0xfffffef9 (PmmC func) args[1] r=1  (not used)
str_PutByte                         -270  0xfffffef2 (PmmC func) args[2] r=0  (not used)
str_PutWord                         -271  0xfffffef1 (PmmC func) args[2] r=0  (not used)
strheight                           -161  0xffffff5f (PmmC func) args[0] r=1  (not used)
strlen                               -10  0xfffffff6 (PmmC func) args[1] r=1  (not used)
strwidth                            -160  0xffffff60 (PmmC func) args[1] r=1  (not used)
STYLE1                                 2  0x00000002 (const dword)  (not used)
STYLE2                                 3  0x00000003 (const dword)  (not used)
SWAP                                 -16  0xfffffff0 (PmmC func) args[2] r=0  (not used)
sys_EventQueue                      -194  0xffffff3e (PmmC func) args[0] r=1  (not used)
sys_EventsPostpone                  -195  0xffffff3d (PmmC func) args[0] r=0  (not used)
sys_EventsResume                    -196  0xffffff3c (PmmC func) args[0] r=0  (not used)
sys_GetTimer                        -192  0xffffff40 (PmmC func) args[1] r=1  (not used)
sys_SetTimer                        -191  0xffffff41 (PmmC func) args[2] r=0  (usage 24)
sys_SetTimerEvent                   -193  0xffffff3f (PmmC func) args[2] r=1  (usage 6)
sys_Sleep                           -197  0xffffff3b (PmmC func) args[1] r=1  (not used)
sys_StoreTouchCalibration           -280  0xfffffee8 (PmmC func) args[0] r=1  (not used)
sys_T                               -189  0xffffff43 (PmmC func) args[0] r=1  (not used)
sys_T_HI                            -190  0xffffff42 (PmmC func) args[0] r=1  (not used)
SYS_X_MAX                             44  0x0000002c (const dword)  (not used)
SYS_Y_MAX                             45  0x0000002d (const dword)  (not used)
SYSTEM_TIMER_HI                       35  0x00000023 (const dword)  (not used)
SYSTEM_TIMER_LO                       34  0x00000022 (const dword)  (usage 9)
TAN                                54705  0x0000d5b1 (const dword)  (not used)
TEAL                                1040  0x00000410 (const dword)  (not used)
temp_cabin                            40  0x00000028 (mem) word (global)  (usage 10)
temp_fuelcell                         44  0x0000002c (mem) word (global)  (usage 10)
temp_outside                          38  0x00000026 (mem) word (global)  (usage 10)
temp_trunk                            42  0x0000002a (mem) word (global)  (usage 10)
TEXT                               63489  0x0000f801 (const dword)  (not used)
TEXT_ATTRIBUTES                       13  0x0000000d (const dword)  (not used)
TEXT_BACKGROUND                        1  0x00000001 (const dword)  (not used)
TEXT_BOLD                              9  0x00000009 (const dword)  (not used)
TEXT_COLOUR                            0  0x00000000 (const dword)  (usage 6)
TEXT_HEIGHT                            4  0x00000004 (const dword)  (not used)
TEXT_HIGHLIGHT                         1  0x00000001 (const dword)  (not used)
TEXT_INVERSE                          11  0x0000000b (const dword)  (not used)
TEXT_ITALIC                           10  0x0000000a (const dword)  (not used)
TEXT_MARGIN                           97  0x00000061 (const dword)  (not used)
TEXT_OPACITY                           8  0x00000008 (const dword)  (not used)
TEXT_PRINTDELAY                        7  0x00000007 (const dword)  (not used)
TEXT_UNDERLINED                       12  0x0000000c (const dword)  (not used)
TEXT_WIDTH                             3  0x00000003 (const dword)  (not used)
TEXT_WRAP                             14  0x0000000e (const dword)  (not used)
TEXT_XGAP                              5  0x00000005 (const dword)  (not used)
TEXT_XPOS                             95  0x0000005f (const dword)  (not used)
TEXT_YGAP                              6  0x00000006 (const dword)  (not used)
TEXT_YPOS                             96  0x00000060 (const dword)  (not used)
THISTLE                            56827  0x0000ddfb (const dword)  (not used)
TIMER0                                 0  0x00000000 (const dword)  (not used)
TIMER1                                 1  0x00000001 (const dword)  (usage 9)
TIMER2                                 2  0x00000002 (const dword)  (usage 21)
TIMER3                                 3  0x00000003 (const dword)  (not used)
TIMER4                                 4  0x00000004 (const dword)  (not used)
TIMER5                                 5  0x00000005 (const dword)  (not used)
TIMER6                                 6  0x00000006 (const dword)  (not used)
TIMER7                                 7  0x00000007 (const dword)  (not used)
tmpbuf                                10  0x0000000a (mem) word[3] (global)  (usage 12)
TMR0                                  36  0x00000024 (const dword)  (not used)
TMR1                                  37  0x00000025 (const dword)  (not used)
TMR2                                  38  0x00000026 (const dword)  (not used)
TMR3                                  39  0x00000027 (const dword)  (not used)
TMR4                                  40  0x00000028 (const dword)  (not used)
TMR5                                  41  0x00000029 (const dword)  (not used)
TMR6                                  42  0x0000002a (const dword)  (not used)
TMR7                                  43  0x0000002b (const dword)  (not used)
to                                    -5  0xfffffffb (PmmC func) args[1] r=1  (not used)
tolower                             -212  0xffffff2c (PmmC func) args[1] r=1  (not used)
TOMATO                             64264  0x0000fb08 (const dword)  (not used)
TOP_POS                                3  0x00000003 (const dword)  (not used)
touch_DetectRegion                  -199  0xffffff39 (PmmC func) args[4] r=0  (not used)
TOUCH_DISABLE                          1  0x00000001 (const dword)  (not used)
TOUCH_DRIVE                           78  0x0000004e (const dword)  (not used)
TOUCH_ENABLE                           0  0x00000000 (const dword)  (usage 3)
touch_Get                           -201  0xffffff37 (PmmC func) args[1] r=1  (usage 9)
TOUCH_GETX                             1  0x00000001 (const dword)  (usage 3)
TOUCH_GETY                             2  0x00000002 (const dword)  (usage 3)
TOUCH_MOVING                           3  0x00000003 (const dword)  (not used)
TOUCH_PRESSED                          1  0x00000001 (const dword)  (usage 3)
TOUCH_RAW_X                          117  0x00000075 (const dword)  (not used)
TOUCH_RAW_Y                          118  0x00000076 (const dword)  (not used)
TOUCH_REGIONDEFAULT                    2  0x00000002 (const dword)  (not used)
TOUCH_RELEASED                         2  0x00000002 (const dword)  (not used)
touch_Set                           -200  0xffffff38 (PmmC func) args[1] r=0  (usage 3)
TOUCH_STATUS                           0  0x00000000 (const dword)  (usage 3)
TOUCH_XMAXCAL                         80  0x00000050 (const dword)  (not used)
TOUCH_XMINCAL                         78  0x0000004e (const dword)  (not used)
TOUCH_YMAXCAL                         81  0x00000051 (const dword)  (not used)
TOUCH_YMINCAL                         79  0x0000004f (const dword)  (not used)
toupper                             -211  0xffffff2d (PmmC func) args[1] r=1  (not used)
translate                             -8  0xfffffff8 (PmmC func) args[4] r=1  (not used)
TRANSPARENCY                          21  0x00000015 (const dword)  (not used)
TRANSPARENT                            0  0x00000000 (const dword)  (not used)
TRANSPARENT_COLOUR                    20  0x00000014 (const dword)  (not used)
trip                                  26  0x0000001a (mem) word (global)  (usage 25)
trip_micro                            32  0x00000020 (mem) word (global)  (usage 22)
TURQUOISE                          18202  0x0000471a (const dword)  (not used)
txt_Attributes                       -38  0xffffffda (PmmC func) args[1] r=1  (not used)
txt_BGcolour                         -26  0xffffffe6 (PmmC func) args[1] r=1  (not used)
txt_Bold                             -34  0xffffffde (PmmC func) args[1] r=1  (not used)
txt_Delay                            -32  0xffffffe0 (PmmC func) args[1] r=1  (not used)
txt_FGcolour                         -25  0xffffffe7 (PmmC func) args[1] r=1  (not used)
TXT_FONT_HEIGHT                      102  0x00000066 (const dword)  (not used)
TXT_FONT_ID                           98  0x00000062 (const dword)  (not used)
TXT_FONT_MAX                          99  0x00000063 (const dword)  (not used)
TXT_FONT_OFFSET                      100  0x00000064 (const dword)  (not used)
TXT_FONT_WIDTH                       101  0x00000065 (const dword)  (not used)
txt_FontID                           -27  0xffffffe5 (PmmC func) args[1] r=1  (not used)
txt_Height                           -29  0xffffffe3 (PmmC func) args[1] r=1  (not used)
txt_Inverse                          -36  0xffffffdc (PmmC func) args[1] r=1  (not used)
txt_Italic                           -35  0xffffffdd (PmmC func) args[1] r=1  (not used)
txt_MoveCursor                       -23  0xffffffe9 (PmmC func) args[2] r=0  (usage 30)
txt_Opacity                          -33  0xffffffdf (PmmC func) args[1] r=1  (not used)
txt_Set                              -24  0xffffffe8 (PmmC func) args[2] r=0  (usage 6)
txt_Underline                        -37  0xffffffdb (PmmC func) args[1] r=1  (not used)
txt_Width                            -28  0xffffffe4 (PmmC func) args[1] r=1  (not used)
txt_Wrap                             -39  0xffffffd9 (PmmC func) args[1] r=1  (not used)
txt_Xgap                             -30  0xffffffe2 (PmmC func) args[1] r=1  (not used)
txt_Ygap                             -31  0xffffffe1 (PmmC func) args[1] r=1  (not used)
uadd_3232                           -290  0xfffffede (PmmC func) args[3] r=1  (not used)
ucmp_3232                           -292  0xfffffedc (PmmC func) args[2] r=1  (not used)
UDEC                               17674  0x0000450a (const dword)  (not used)
UDEC1                              16650  0x0000410a (const dword)  (not used)
UDEC1Z                             20746  0x0000510a (const dword)  (not used)
UDEC1ZB                            24842  0x0000610a (const dword)  (not used)
UDEC2                              16906  0x0000420a (const dword)  (not used)
UDEC2Z                             21002  0x0000520a (const dword)  (not used)
UDEC2ZB                            25098  0x0000620a (const dword)  (not used)
UDEC3                              17162  0x0000430a (const dword)  (not used)
UDEC3Z                             21258  0x0000530a (const dword)  (not used)
UDEC3ZB                            25354  0x0000630a (const dword)  (not used)
UDEC4                              17418  0x0000440a (const dword)  (not used)
UDEC4Z                             21514  0x0000540a (const dword)  (not used)
UDEC4ZB                            25610  0x0000640a (const dword)  (not used)
UDEC5                              17674  0x0000450a (const dword)  (not used)
UDEC5Z                             21770  0x0000550a (const dword)  (not used)
UDEC5ZB                            25866  0x0000650a (const dword)  (not used)
UDECZ                              21770  0x0000550a (const dword)  (not used)
UDECZB                             25866  0x0000650a (const dword)  (not used)
uLCD_43PT_GFX2                         0  0x00000000 (const ??? 0)  (not used)
umul_1616                           -289  0xfffffedf (PmmC func) args[3] r=1  (not used)
UNDERLINED                           128  0x00000080 (const dword)  (not used)
unicode_page                        -281  0xfffffee7 (PmmC func) args[3] r=1  (not used)
UP                                     1  0x00000001 (const dword)  (not used)
update_odo                          5568  0x000015c0 (User func) args[0] r=0  (usage 3)
USER_INITIALIZED_DISPLAY              32  0x00000020 (const dword)  (not used)
usub_3232                           -291  0xfffffedd (PmmC func) args[3] r=1  (not used)
vaccessory                            48  0x00000030 (mem) word (global)  (usage 13)
VIOLET                             60445  0x0000ec1d (const dword)  (not used)
vstack                                46  0x0000002e (mem) word (global)  (usage 13)
WHEAT                              63222  0x0000f6f6 (const dword)  (not used)
WHITE                              65535  0x0000ffff (const dword)  (not used)
WHITESMOKE                         63422  0x0000f7be (const dword)  (not used)
WRITE_PAGE                            35  0x00000023 (const dword)  (not used)
X_MAX                                  0  0x00000000 (const dword)  (not used)
X_ORG                                  6  0x00000006 (const dword)  (not used)
X_ORIGIN                              30  0x0000001e (const dword)  (not used)
Y_MAX                                  1  0x00000001 (const dword)  (not used)
Y_ORG                                  7  0x00000007 (const dword)  (not used)
Y_ORIGIN                              31  0x0000001f (const dword)  (not used)
YELLOW                             65504  0x0000ffe0 (const dword)  (usage 18)
YELLOWGREEN                        40550  0x00009e66 (const dword)  (not used)
